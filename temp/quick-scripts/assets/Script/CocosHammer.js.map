{"version":3,"sources":["CocosHammer.js"],"names":["exportName","undefined","TYPE_FUNCTION","round","Math","abs","now","Date","setTimeoutContext","fn","timeout","context","setTimeout","bindFn","invokeArrayArg","arg","Array","isArray","each","obj","iterator","i","forEach","length","call","hasOwnProperty","deprecate","method","name","message","deprecationMessage","e","Error","stack","replace","log","window","console","warn","apply","arguments","assign","Object","target","TypeError","output","index","source","nextKey","extend","dest","src","merge","keys","inherit","child","base","properties","baseP","prototype","childP","create","constructor","_super","boundFn","boolOrFn","val","args","ifUndefined","val1","val2","addEventListeners","types","handler","splitStr","type","on","removeEventListeners","off","hasParent","node","parent","inStr","str","find","indexOf","trim","split","inArray","findByKey","toArray","slice","uniqueArray","key","sort","results","values","push","sortUniqueArray","a","b","_uniqueId","uniqueId","getWindowForElement","element","doc","ownerDocument","defaultView","parentWindow","INPUT_TYPE_TOUCH","COMPUTE_INTERVAL","INPUT_START","INPUT_MOVE","INPUT_END","INPUT_CANCEL","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL","PROPS_XY","PROPS_CLIENT_XY","Input","manager","callback","self","options","inputTarget","nodeHandler","ev","enable","init","evEl","evTarget","evWin","destroy","createInputInstance","Type","inputClass","TouchInput","inputHandler","eventType","input","pointersLen","pointers","changedPointersLen","changedPointers","isFirst","isFinal","session","computeInputData","emit","recognize","prevInput","pointersLength","firstInput","simpleCloneInputData","firstMultiple","offsetCenter","center","getCenter","timeStamp","deltaTime","angle","getAngle","distance","getDistance","computeDeltaXY","offsetDirection","getDirection","deltaX","deltaY","overallVelocity","getVelocity","overallVelocityX","x","overallVelocityY","y","scale","getScale","rotation","getRotation","maxPointers","computeIntervalInputData","srcEvent","offset","offsetDelta","prevDelta","last","lastInterval","velocity","velocityX","velocityY","direction","v","p1","p2","props","sqrt","atan2","PI","start","end","TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","TOUCH_TARGET_EVENTS","targetIds","MTEhandler","getLocation","pointerType","STATE_POSSIBLE","STATE_BEGAN","STATE_CHANGED","STATE_ENDED","STATE_RECOGNIZED","STATE_CANCELLED","STATE_FAILED","Recognizer","defaults","id","state","simultaneous","requireFail","set","touchAction","update","recognizeWith","otherRecognizer","getRecognizerByNameIfManager","dropRecognizeWith","requireFailure","dropRequireFailure","splice","hasRequireFailures","canRecognizeWith","event","stateStr","additionalEvent","tryEmit","canEmit","inputData","inputDataClone","reset","process","directionStr","recognizer","get","AttrRecognizer","attrTest","optionPointers","isRecognized","isValid","PanRecognizer","pX","pY","threshold","directionTest","hasMoved","PinchRecognizer","inOut","PressRecognizer","_timer","_input","time","validPointers","validMovement","validTime","clearTimeout","RotateRecognizer","SwipeRecognizer","getTouchAction","TapRecognizer","pTime","pCenter","count","taps","interval","posThreshold","validTouchTime","failTimeout","validInterval","validMultiTap","tapCount","Hammer","recognizers","preset","Manager","VERSION","STOP","FORCED_STOP","handlers","item","add","stop","force","stopped","curRecognizer","existing","remove","events","data","Tap","Pan","Swipe","Pinch","Rotate","Press","freeGlobal","define","amd","module","exports"],"mappings":"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","file":"CocosHammer.js","sourceRoot":"../../../../assets/Script","sourcesContent":["(function(exportName, undefined) {\n  \"use strict\";\n\n  var TYPE_FUNCTION = \"function\";\n\n  var round = Math.round;\n  var abs = Math.abs;\n  var now = Date.now;\n\n  /**\n   * set a timeout with a given scope\n   * @param {Function} fn\n   * @param {Number} timeout\n   * @param {Object} context\n   * @returns {number}\n   */\n  function setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n  }\n\n  /**\n   * if the argument is an array, we want to execute the fn on each entry\n   * if it aint an array we don't want to do a thing.\n   * this is used by all the methods that accept a single and array argument.\n   * @param {*|Array} arg\n   * @param {String} fn\n   * @param {Object} [context]\n   * @returns {Boolean}\n   */\n  function invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n      each(arg, context[fn], context);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * walk objects and arrays\n   * @param {Object} obj\n   * @param {Function} iterator\n   * @param {Object} context\n   */\n  function each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n      return;\n    }\n\n    if (obj.forEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n      i = 0;\n      while (i < obj.length) {\n        iterator.call(context, obj[i], i, obj);\n        i++;\n      }\n    } else {\n      for (i in obj) {\n        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n      }\n    }\n  }\n\n  /**\n   * wrap a method with a deprecation warning and stack trace\n   * @param {Function} method\n   * @param {String} name\n   * @param {String} message\n   * @returns {Function} A new function wrapping the supplied method.\n   */\n  function deprecate(method, name, message) {\n    var deprecationMessage =\n      \"DEPRECATED METHOD: \" + name + \"\\n\" + message + \" AT \\n\";\n    return function() {\n      var e = new Error(\"get-stack-trace\");\n      var stack =\n        e && e.stack\n          ? e.stack\n              .replace(/^[^\\(]+?[\\n$]/gm, \"\")\n              .replace(/^\\s+at\\s+/gm, \"\")\n              .replace(/^Object.<anonymous>\\s*\\(/gm, \"{anonymous}()@\")\n          : \"Unknown Stack Trace\";\n\n      var log = window.console && (window.console.warn || window.console.log);\n      if (log) {\n        log.call(window.console, deprecationMessage, stack);\n      }\n      return method.apply(this, arguments);\n    };\n  }\n\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} target\n   * @param {...Object} objects_to_assign\n   * @returns {Object} target\n   */\n  var assign;\n  if (typeof Object.assign !== \"function\") {\n    assign = function assign(target) {\n      if (target === undefined || target === null) {\n        throw new TypeError(\"Cannot convert undefined or null to object\");\n      }\n\n      var output = Object(target);\n      for (var index = 1; index < arguments.length; index++) {\n        var source = arguments[index];\n        if (source !== undefined && source !== null) {\n          for (var nextKey in source) {\n            if (source.hasOwnProperty(nextKey)) {\n              output[nextKey] = source[nextKey];\n            }\n          }\n        }\n      }\n      return output;\n    };\n  } else {\n    assign = Object.assign;\n  }\n\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} dest\n   * @param {Object} src\n   * @param {Boolean} [merge=false]\n   * @returns {Object} dest\n   */\n  var extend = deprecate(\n    function extend(dest, src, merge) {\n      var keys = Object.keys(src);\n      var i = 0;\n      while (i < keys.length) {\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\n          dest[keys[i]] = src[keys[i]];\n        }\n        i++;\n      }\n      return dest;\n    },\n    \"extend\",\n    \"Use `assign`.\"\n  );\n\n  /**\n   * merge the values from src in the dest.\n   * means that properties that exist in dest will not be overwritten by src\n   * @param {Object} dest\n   * @param {Object} src\n   * @returns {Object} dest\n   */\n  var merge = deprecate(\n    function merge(dest, src) {\n      return extend(dest, src, true);\n    },\n    \"merge\",\n    \"Use `assign`.\"\n  );\n\n  /**\n   * simple class inheritance\n   * @param {Function} child\n   * @param {Function} base\n   * @param {Object} [properties]\n   */\n  function inherit(child, base, properties) {\n    var baseP = base.prototype,\n      childP;\n\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n      assign(childP, properties);\n    }\n  }\n\n  /**\n   * simple function bind\n   * @param {Function} fn\n   * @param {Object} context\n   * @returns {Function}\n   */\n  function bindFn(fn, context) {\n    return function boundFn() {\n      return fn.apply(context, arguments);\n    };\n  }\n\n  /**\n   * let a boolean value also be a function that must return a boolean\n   * this first item in args will be used as the context\n   * @param {Boolean|Function} val\n   * @param {Array} [args]\n   * @returns {Boolean}\n   */\n  function boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n      return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n  }\n\n  /**\n   * use the val2 when val1 is undefined\n   * @param {*} val1\n   * @param {*} val2\n   * @returns {*}\n   */\n  function ifUndefined(val1, val2) {\n    return val1 === undefined ? val2 : val1;\n  }\n\n  /**\n   * addEventListener with multiple events at once\n   * @param {cc.Node reference cc.EventTarget} target\n   * @param {String} types\n   * @param {Function} handler\n   */\n  function addEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n      target.on(type, handler);\n    });\n  }\n\n  /**\n   * removeEventListener with multiple events at once\n   * @param {cc.Node reference cc.EventTarget} target\n   * @param {cc.Node.EventType} types\n   * @param {Function} handler\n   */\n  function removeEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n      target.off(type, handler);\n    });\n  }\n\n  /**\n   * find if a node is in the given parent\n   * @method hasParent\n   * @param {cc.Node} node\n   * @param {cc.Node} parent\n   * @return {Boolean} found\n   */\n  function hasParent(node, parent) {\n    while (node) {\n      if (node == parent) {\n        return true;\n      }\n      node = node.parent;\n    }\n    return false;\n  }\n\n  /**\n   * small indexOf wrapper\n   * @param {String} str\n   * @param {String} find\n   * @returns {Boolean} found\n   */\n  function inStr(str, find) {\n    return str.indexOf(find) > -1;\n  }\n\n  /**\n   * split string on whitespace\n   * @param {String} str\n   * @returns {Array} words\n   */\n  function splitStr(str) {\n    return str.trim().split(/\\s+/g);\n  }\n\n  /**\n   * find if a array contains the object using indexOf or a simple polyFill\n   * @param {Array} src\n   * @param {String} find\n   * @param {String} [findByKey]\n   * @return {Boolean|Number} false when not found, or the index\n   */\n  function inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n      return src.indexOf(find);\n    } else {\n      var i = 0;\n      while (i < src.length) {\n        if (\n          (findByKey && src[i][findByKey] == find) ||\n          (!findByKey && src[i] === find)\n        ) {\n          return i;\n        }\n        i++;\n      }\n      return -1;\n    }\n  }\n\n  /**\n   * convert array-like objects to real arrays\n   * @param {Object} obj\n   * @returns {Array}\n   */\n  function toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n  }\n\n  /**\n   * unique array with objects based on a key (like 'id') or just by the array's value\n   * @param {Array} src [{id:1},{id:2},{id:1}]\n   * @param {String} [key]\n   * @param {Boolean} [sort=False]\n   * @returns {Array} [{id:1},{id:2}]\n   */\n  function uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n      var val = key ? src[i][key] : src[i];\n      if (inArray(values, val) < 0) {\n        results.push(src[i]);\n      }\n      values[i] = val;\n      i++;\n    }\n\n    if (sort) {\n      if (!key) {\n        results = results.sort();\n      } else {\n        results = results.sort(function sortUniqueArray(a, b) {\n          return a[key] > b[key];\n        });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * get a unique id\n   * @returns {number} uniqueId\n   */\n  var _uniqueId = 1;\n  function uniqueId() {\n    return _uniqueId++;\n  }\n\n  /**\n   * get the window object of an element\n   * @param {HTMLElement} element\n   * @returns {DocumentView|Window}\n   */\n  function getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return doc.defaultView || doc.parentWindow || window;\n  }\n\n  var INPUT_TYPE_TOUCH = \"touch\";\n\n  var COMPUTE_INTERVAL = 25;\n\n  var INPUT_START = 1;\n  var INPUT_MOVE = 2;\n  var INPUT_END = 4;\n  var INPUT_CANCEL = 8;\n\n  var DIRECTION_NONE = 1;\n  var DIRECTION_LEFT = 2;\n  var DIRECTION_RIGHT = 4;\n  var DIRECTION_UP = 8;\n  var DIRECTION_DOWN = 16;\n\n  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\n  var PROPS_XY = [\"x\", \"y\"];\n  var PROPS_CLIENT_XY = [\"clientX\", \"clientY\"];\n\n  /**\n   * create new input type manager\n   * @param {Manager} manager\n   * @param {Function} callback\n   * @returns {Input}\n   * @constructor\n   */\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.nodeHandler = function(ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n\n    this.init();\n  }\n\n  Input.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function() {},\n\n    /**\n     * bind the events\n     */\n    init: function() {\n      this.evEl && addEventListeners(this.element, this.evEl, this.nodeHandler);\n      this.evTarget &&\n        addEventListeners(this.target, this.evTarget, this.nodeHandler);\n      this.evWin &&\n        addEventListeners(\n          getWindowForElement(this.element),\n          this.evWin,\n          this.nodeHandler\n        );\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function() {\n      this.evEl &&\n        removeEventListeners(this.element, this.evEl, this.nodeHandler);\n      this.evTarget &&\n        removeEventListeners(this.target, this.evTarget, this.nodeHandler);\n      this.evWin &&\n        removeEventListeners(\n          getWindowForElement(this.element),\n          this.evWin,\n          this.nodeHandler\n        );\n    }\n  };\n\n  /**\n   * create new input type manager\n   * called by the Manager constructor\n   * @param {Hammer} manager\n   * @returns {Input}\n   */\n  function createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n      Type = inputClass;\n    } else {\n      Type = TouchInput;\n    }\n    return new Type(manager, inputHandler);\n  }\n\n  /**\n   * handle input events\n   * @param {Manager} manager\n   * @param {String} eventType\n   * @param {Object} input\n   */\n  function inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst =\n      eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n    var isFinal =\n      eventType & (INPUT_END | INPUT_CANCEL) &&\n      pointersLen - changedPointersLen === 0;\n\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n      manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit(\"hammer.input\", input);\n\n    manager.recognize(input);\n    manager.session.prevInput = input;\n  }\n\n  /**\n   * extend the data with some usable properties like scale, rotate, velocity etc\n   * @param {Object} manager\n   * @param {Object} input\n   */\n  function computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n      session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n      session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n      session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n    var center = (input.center = getCenter(pointers));\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n    var overallVelocity = getVelocity(\n      input.deltaTime,\n      input.deltaX,\n      input.deltaY\n    );\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity =\n      abs(overallVelocity.x) > abs(overallVelocity.y)\n        ? overallVelocity.x\n        : overallVelocity.y;\n\n    input.scale = firstMultiple\n      ? getScale(firstMultiple.pointers, pointers)\n      : 1;\n    input.rotation = firstMultiple\n      ? getRotation(firstMultiple.pointers, pointers)\n      : 0;\n\n    input.maxPointers = !session.prevInput\n      ? input.pointers.length\n      : input.pointers.length > session.prevInput.maxPointers\n      ? input.pointers.length\n      : session.prevInput.maxPointers;\n\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n      target = input.srcEvent.target;\n    }\n\n    input.target = target;\n  }\n\n  function computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n      prevDelta = session.prevDelta = {\n        x: prevInput.deltaX || 0,\n        y: prevInput.deltaY || 0\n      };\n\n      offset = session.offsetDelta = {\n        x: center.x,\n        y: center.y\n      };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n  }\n\n  /**\n   * velocity is calculated every x ms\n   * @param {Object} session\n   * @param {Object} input\n   */\n  function computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n      deltaTime = input.timeStamp - last.timeStamp,\n      velocity,\n      velocityX,\n      velocityY,\n      direction;\n\n    if (\n      input.eventType != INPUT_CANCEL &&\n      (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)\n    ) {\n      var deltaX = input.deltaX - last.deltaX;\n      var deltaY = input.deltaY - last.deltaY;\n\n      var v = getVelocity(deltaTime, deltaX, deltaY);\n      velocityX = v.x;\n      velocityY = v.y;\n      velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n      direction = getDirection(deltaX, deltaY);\n\n      session.lastInterval = input;\n    } else {\n      // use latest velocity info if it doesn't overtake a minimum period\n      velocity = last.velocity;\n      velocityX = last.velocityX;\n      velocityY = last.velocityY;\n      direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n  }\n\n  /**\n   * create a simple clone from the input used for storage of firstInput and firstMultiple\n   * @param {Object} input\n   * @returns {Object} clonedInputData\n   */\n  function simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n      pointers[i] = {\n        x: round(input.pointers[i].x),\n        y: round(input.pointers[i].y)\n      };\n      i++;\n    }\n\n    return {\n      timeStamp: now(),\n      pointers: pointers,\n      center: getCenter(pointers),\n      deltaX: input.deltaX,\n      deltaY: input.deltaY\n    };\n  }\n\n  /**\n   * get the center of all the pointers\n   * @param {Array} pointers\n   * @return {Object} center contains `x` and `y` properties\n   */\n  function getCenter(pointers) {\n    var pointersLength = pointers.length;\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n      return {\n        x: round(pointers[0].x),\n        y: round(pointers[0].y)\n      };\n    }\n\n    var x = 0,\n      y = 0,\n      i = 0;\n    while (i < pointersLength) {\n      x += pointers[i].x;\n      y += pointers[i].y;\n      i++;\n    }\n\n    return {\n      x: round(x / pointersLength),\n      y: round(y / pointersLength)\n    };\n  }\n\n  /**\n   * calculate the velocity between two points. unit is in px per ms.\n   * @param {Number} deltaTime\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Object} velocity `x` and `y`\n   */\n  function getVelocity(deltaTime, x, y) {\n    return {\n      x: x / deltaTime || 0,\n      y: y / deltaTime || 0\n    };\n  }\n\n  /**\n   * get the direction between two points\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Number} direction\n   */\n  function getDirection(x, y) {\n    if (x === y) {\n      return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n      return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n  }\n\n  /**\n   * calculate the absolute distance between two points\n   * @param {Object} p1 {x, y}\n   * @param {Object} p2 {x, y}\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} distance\n   */\n  function getDistance(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n      y = p2[props[1]] - p1[props[1]];\n\n    return Math.sqrt(x * x + y * y);\n  }\n\n  /**\n   * calculate the angle between two coordinates\n   * @param {Object} p1\n   * @param {Object} p2\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} angle\n   */\n  function getAngle(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n      y = p2[props[1]] - p1[props[1]];\n    return (Math.atan2(y, x) * 180) / Math.PI;\n  }\n\n  /**\n   * calculate the rotation degrees between two pointersets\n   * @param {Array} start array of pointers\n   * @param {Array} end array of pointers\n   * @return {Number} rotation\n   */\n  function getRotation(start, end) {\n    return (\n      getAngle(end[1], end[0], PROPS_CLIENT_XY) +\n      getAngle(start[1], start[0], PROPS_CLIENT_XY)\n    );\n  }\n\n  /**\n   * calculate the scale factor between two pointersets\n   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n   * @param {Array} start array of pointers\n   * @param {Array} end array of pointers\n   * @return {Number} scale\n   */\n  function getScale(start, end) {\n    return (\n      getDistance(end[0], end[1], PROPS_CLIENT_XY) /\n      getDistance(start[0], start[1], PROPS_CLIENT_XY)\n    );\n  }\n\n  var TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n  };\n\n  var TOUCH_TARGET_EVENTS = \"touchstart touchmove touchend touchcancel\";\n\n  /**\n   * Multi-user touch events input\n   * @constructor\n   * @extends Input\n   */\n  function TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n\n    Input.apply(this, arguments);\n  }\n\n  inherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n      var type = TOUCH_INPUT_MAP[ev.type];\n      //var touches = getTouches.call(this, ev, type);\n      // var touches = {\n\n      // };\n      // if (!touches) {\n      //     return;\n      // }\n\n      this.callback(this.manager, type, {\n        pointers: [ev.getLocation()],\n        changedPointers: [ev.getLocation()],\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  });\n\n  /**\n   * Recognizer flow explained; *\n   * All recognizers have the initial state of POSSIBLE when a input session starts.\n   * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n   * Example session for mouse-input: mousedown -> mousemove -> mouseup\n   *\n   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n   * which determines with state it should be.\n   *\n   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n   * POSSIBLE to give it another change on the next cycle.\n   *\n   *               Possible\n   *                  |\n   *            +-----+---------------+\n   *            |                     |\n   *      +-----+-----+               |\n   *      |           |               |\n   *   Failed      Cancelled          |\n   *                          +-------+------+\n   *                          |              |\n   *                      Recognized       Began\n   *                                         |\n   *                                      Changed\n   *                                         |\n   *                                  Ended/Recognized\n   */\n  var STATE_POSSIBLE = 1;\n  var STATE_BEGAN = 2;\n  var STATE_CHANGED = 4;\n  var STATE_ENDED = 8;\n  var STATE_RECOGNIZED = STATE_ENDED;\n  var STATE_CANCELLED = 16;\n  var STATE_FAILED = 32;\n\n  /**\n   * Recognizer\n   * Every recognizer needs to extend from this class.\n   * @constructor\n   * @param {Object} options\n   */\n  function Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n\n  Recognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function(options) {\n      assign(this.options, options);\n\n      // also update the touchAction, in case something changed about the directions/enabled state\n      this.manager && this.manager.touchAction.update();\n      return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, \"recognizeWith\", this)) {\n        return this;\n      }\n\n      var simultaneous = this.simultaneous;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      if (!simultaneous[otherRecognizer.id]) {\n        simultaneous[otherRecognizer.id] = otherRecognizer;\n        otherRecognizer.recognizeWith(this);\n      }\n      return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, \"dropRecognizeWith\", this)) {\n        return this;\n      }\n\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      delete this.simultaneous[otherRecognizer.id];\n      return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, \"requireFailure\", this)) {\n        return this;\n      }\n\n      var requireFail = this.requireFail;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      if (inArray(requireFail, otherRecognizer) === -1) {\n        requireFail.push(otherRecognizer);\n        otherRecognizer.requireFailure(this);\n      }\n      return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, \"dropRequireFailure\", this)) {\n        return this;\n      }\n\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      var index = inArray(this.requireFail, otherRecognizer);\n      if (index > -1) {\n        this.requireFail.splice(index, 1);\n      }\n      return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function() {\n      return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function(otherRecognizer) {\n      return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function(input) {\n      var self = this;\n      var state = this.state;\n\n      function emit(event) {\n        self.manager.emit(event, input);\n      }\n\n      // 'panstart' and 'panmove'\n      if (state < STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n\n      emit(self.options.event); // simple 'eventName' events\n\n      if (input.additionalEvent) {\n        // additional event(panleft, panright, pinchin, pinchout...)\n        emit(input.additionalEvent);\n      }\n\n      // panend and pancancel\n      if (state >= STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function(input) {\n      if (this.canEmit()) {\n        console.log(\"canEmit\");\n        return this.emit(input);\n      }\n      // it's failing anyway\n      this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function() {\n      var i = 0;\n      while (i < this.requireFail.length) {\n        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n          return false;\n        }\n        i++;\n      }\n      return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n      // make a new copy of the inputData\n      // so we can change the inputData without messing up the other recognizers\n      var inputDataClone = assign({}, inputData);\n\n      // is is enabled and allow recognizing?\n      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n        this.reset();\n        this.state = STATE_FAILED;\n        return;\n      }\n\n      // reset when we've reached the end\n      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n        this.state = STATE_POSSIBLE;\n      }\n\n      this.state = this.process(inputDataClone);\n\n      // the recognizer has recognized a gesture\n      // so trigger an event\n      if (\n        this.state &\n        (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)\n      ) {\n        console.log(\"success state:\", this.state);\n        console.log(\"success data:\", inputDataClone);\n        this.tryEmit(inputDataClone);\n      }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function(inputData) {}, // jshint ignore:line\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function() {}\n  };\n\n  /**\n   * get a usable string, used as event postfix\n   * @param {Const} state\n   * @returns {String} state\n   */\n  function stateStr(state) {\n    if (state & STATE_CANCELLED) {\n      return \"cancel\";\n    } else if (state & STATE_ENDED) {\n      return \"end\";\n    } else if (state & STATE_CHANGED) {\n      return \"move\";\n    } else if (state & STATE_BEGAN) {\n      return \"start\";\n    }\n    return \"\";\n  }\n\n  /**\n   * direction cons to string\n   * @param {Const} direction\n   * @returns {String}\n   */\n  function directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n      return \"down\";\n    } else if (direction == DIRECTION_UP) {\n      return \"up\";\n    } else if (direction == DIRECTION_LEFT) {\n      return \"left\";\n    } else if (direction == DIRECTION_RIGHT) {\n      return \"right\";\n    }\n    return \"\";\n  }\n\n  /**\n   * get a recognizer by name if it is bound to a manager\n   * @param {Recognizer|String} otherRecognizer\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer}\n   */\n  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n      return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n  }\n\n  /**\n   * This recognizer is just used as a base for the simple attribute recognizers.\n   * @constructor\n   * @extends Recognizer\n   */\n  function AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n  }\n\n  inherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n      /**\n       * @type {Number}\n       * @default 1\n       */\n      pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function(input) {\n      var optionPointers = this.options.pointers;\n      return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function(input) {\n      var state = this.state;\n      var eventType = input.eventType;\n\n      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n      var isValid = this.attrTest(input);\n\n      // on cancel input and we've recognized before, return STATE_CANCELLED\n      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n        return state | STATE_CANCELLED;\n      } else if (isRecognized || isValid) {\n        if (eventType & INPUT_END) {\n          return state | STATE_ENDED;\n        } else if (!(state & STATE_BEGAN)) {\n          return STATE_BEGAN;\n        }\n        return state | STATE_CHANGED;\n      }\n      return STATE_FAILED;\n    }\n  });\n\n  /**\n   * Pan\n   * Recognized when the pointer is down and moved in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n\n    this.pX = null;\n    this.pY = null;\n  }\n\n  inherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n      event: \"pan\",\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    },\n\n    directionTest: function(input) {\n      var options = this.options;\n      var hasMoved = true;\n      var distance = input.distance;\n      var direction = input.direction;\n      var x = input.deltaX;\n      var y = input.deltaY;\n\n      // lock to axis?\n      if (!(direction & options.direction)) {\n        if (options.direction & DIRECTION_HORIZONTAL) {\n          direction =\n            x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n          hasMoved = x != this.pX;\n          distance = Math.abs(input.deltaX);\n        } else {\n          direction =\n            y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n          hasMoved = y != this.pY;\n          distance = Math.abs(input.deltaY);\n        }\n      }\n      input.direction = direction;\n      return (\n        hasMoved &&\n        distance > options.threshold &&\n        direction & options.direction\n      );\n    },\n\n    attrTest: function(input) {\n      return (\n        AttrRecognizer.prototype.attrTest.call(this, input) &&\n        (this.state & STATE_BEGAN ||\n          (!(this.state & STATE_BEGAN) && this.directionTest(input)))\n      );\n    },\n\n    emit: function(input) {\n      this.pX = input.deltaX;\n      this.pY = input.deltaY;\n      var direction = directionStr(input.direction);\n\n      if (direction) {\n        input.additionalEvent = this.options.event + direction;\n      }\n      this._super.emit.call(this, input);\n    }\n  });\n\n  /**\n   * Pinch\n   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n      event: \"pinch\",\n      threshold: 0,\n      pointers: 2\n    },\n\n    attrTest: function(input) {\n      return (\n        this._super.attrTest.call(this, input) &&\n        (Math.abs(input.scale - 1) > this.options.threshold ||\n          this.state & STATE_BEGAN)\n      );\n    },\n\n    emit: function(input) {\n      if (input.scale !== 1) {\n        var inOut = input.scale < 1 ? \"in\" : \"out\";\n        input.additionalEvent = this.options.event + inOut;\n      }\n      this._super.emit.call(this, input);\n    }\n  });\n\n  /**\n   * Press\n   * Recognized when the pointer is down for x ms without any movement.\n   * @constructor\n   * @extends Recognizer\n   */\n  function PressRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    this._timer = null;\n    this._input = null;\n  }\n\n  inherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n      event: \"press\",\n      pointers: 1,\n      time: 251, // minimal time of the pointer to be pressed\n      threshold: 9 // a minimal movement is ok, but keep it low\n    },\n\n    process: function(input) {\n      var options = this.options;\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTime = input.deltaTime > options.time;\n\n      this._input = input;\n\n      // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n      if (\n        !validMovement ||\n        !validPointers ||\n        (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)\n      ) {\n        this.reset();\n      } else if (input.eventType & INPUT_START) {\n        this.reset();\n        this._timer = setTimeoutContext(\n          function() {\n            this.state = STATE_RECOGNIZED;\n            this.tryEmit();\n          },\n          options.time,\n          this\n        );\n      } else if (input.eventType & INPUT_END) {\n        return STATE_RECOGNIZED;\n      }\n      return STATE_FAILED;\n    },\n\n    reset: function() {\n      clearTimeout(this._timer);\n    },\n\n    emit: function(input) {\n      if (this.state !== STATE_RECOGNIZED) {\n        return;\n      }\n\n      if (input && input.eventType & INPUT_END) {\n        this.manager.emit(this.options.event + \"up\", input);\n      } else {\n        this._input.timeStamp = now();\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n\n  /**\n   * Rotate\n   * Recognized when two or more pointer are moving in a circular motion.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n      event: \"rotate\",\n      threshold: 0,\n      pointers: 2\n    },\n\n    attrTest: function(input) {\n      return (\n        this._super.attrTest.call(this, input) &&\n        (Math.abs(input.rotation) > this.options.threshold ||\n          this.state & STATE_BEGAN)\n      );\n    }\n  });\n\n  /**\n   * Swipe\n   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n      event: \"swipe\",\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    },\n\n    getTouchAction: function() {\n      return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n\n    attrTest: function(input) {\n      var direction = this.options.direction;\n      var velocity;\n\n      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n        velocity = input.overallVelocity;\n      } else if (direction & DIRECTION_HORIZONTAL) {\n        velocity = input.overallVelocityX;\n      } else if (direction & DIRECTION_VERTICAL) {\n        velocity = input.overallVelocityY;\n      }\n\n      return (\n        this._super.attrTest.call(this, input) &&\n        direction & input.offsetDirection &&\n        input.distance > this.options.threshold &&\n        input.maxPointers == this.options.pointers &&\n        abs(velocity) > this.options.velocity &&\n        input.eventType & INPUT_END\n      );\n    },\n\n    emit: function(input) {\n      var direction = directionStr(input.offsetDirection);\n      if (direction) {\n        this.manager.emit(this.options.event + direction, input);\n      }\n\n      this.manager.emit(this.options.event, input);\n    }\n  });\n\n  /**\n   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n   * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n   * a single tap.\n   *\n   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n   * multi-taps being recognized.\n   * @constructor\n   * @extends Recognizer\n   */\n  function TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n  }\n\n  inherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n      event: \"tap\",\n      pointers: 1,\n      taps: 1,\n      interval: 300, // max time between the multi-tap taps\n      time: 250, // max time of the pointer to be down (like finger on the screen)\n      threshold: 9, // a minimal movement is ok, but keep it low\n      posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    process: function(input) {\n      var options = this.options;\n\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTouchTime = input.deltaTime < options.time;\n\n      this.reset();\n\n      if (input.eventType & INPUT_START && this.count === 0) {\n        return this.failTimeout();\n      }\n\n      // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n      if (validMovement && validTouchTime && validPointers) {\n        if (input.eventType != INPUT_END) {\n          return this.failTimeout();\n        }\n\n        var validInterval = this.pTime\n          ? input.timeStamp - this.pTime < options.interval\n          : true;\n        var validMultiTap =\n          !this.pCenter ||\n          getDistance(this.pCenter, input.center) < options.posThreshold;\n\n        this.pTime = input.timeStamp;\n        this.pCenter = input.center;\n\n        if (!validMultiTap || !validInterval) {\n          this.count = 1;\n        } else {\n          this.count += 1;\n        }\n\n        this._input = input;\n\n        // if tap count matches we have recognized it,\n        // else it has began recognizing...\n        var tapCount = this.count % options.taps;\n        if (tapCount === 0) {\n          // no failing requirements, immediately trigger the tap event\n          // or wait as long as the multitap interval to trigger\n          if (!this.hasRequireFailures()) {\n            return STATE_RECOGNIZED;\n          } else {\n            this._timer = setTimeoutContext(\n              function() {\n                this.state = STATE_RECOGNIZED;\n                this.tryEmit();\n              },\n              options.interval,\n              this\n            );\n            return STATE_BEGAN;\n          }\n        }\n      }\n      return STATE_FAILED;\n    },\n\n    failTimeout: function() {\n      this._timer = setTimeoutContext(\n        function() {\n          this.state = STATE_FAILED;\n        },\n        this.options.interval,\n        this\n      );\n      return STATE_FAILED;\n    },\n\n    reset: function() {\n      clearTimeout(this._timer);\n    },\n\n    emit: function() {\n      if (this.state == STATE_RECOGNIZED) {\n        this._input.tapCount = this.count;\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n\n  /**\n   * Simple way to create a manager with a default set of recognizers.\n   * @param {cc.Node} element\n   * @param {Object} [options]\n   * @constructor\n   */\n  function Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(\n      options.recognizers,\n      Hammer.defaults.preset\n    );\n    return new Manager(element, options);\n  }\n\n  /**\n   * @const {string}\n   */\n  Hammer.VERSION = \"2.0.8\";\n\n  /**\n   * default settings\n   * @namespace\n   */\n  Hammer.defaults = {\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: TouchInput,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n      // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n      [RotateRecognizer, { enable: false }],\n      [PinchRecognizer, { enable: false }, [\"rotate\"]],\n      [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],\n      [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, [\"swipe\"]],\n      [TapRecognizer],\n      [TapRecognizer, { event: \"doubletap\", taps: 2 }, [\"tap\"]],\n      [PressRecognizer]\n    ]\n  };\n\n  var STOP = 1;\n  var FORCED_STOP = 2;\n\n  /**\n   * Manager\n   * @param {cc.Node} element\n   * @param {Object} [options]\n   * @constructor\n   */\n  function Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n\n    this.element = element;\n    this.input = createInputInstance(this);\n\n    each(\n      this.options.recognizers,\n      function(item) {\n        var recognizer = this.add(new item[0](item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n      },\n      this\n    );\n  }\n\n  Manager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function(options) {\n      assign(this.options, options);\n\n      if (options.inputTarget) {\n        // Clean up existing event listeners and reinitialize\n        this.input.destroy();\n        this.input.target = options.inputTarget;\n        this.input.init();\n      }\n      return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function(force) {\n      this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n      var session = this.session;\n      if (session.stopped) {\n        return;\n      }\n\n      var recognizer;\n      var recognizers = this.recognizers;\n\n      // this holds the recognizer that is being recognized.\n      // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n      // if no recognizer is detecting a thing, it is set to `null`\n      var curRecognizer = session.curRecognizer;\n\n      // reset when the last recognizer is recognized\n      // or when we're in a new session\n      if (\n        !curRecognizer ||\n        (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)\n      ) {\n        curRecognizer = session.curRecognizer = null;\n      }\n\n      var i = 0;\n      while (i < recognizers.length) {\n        recognizer = recognizers[i];\n\n        // find out if we are allowed try to recognize the input for this one.\n        // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n        //      that is being recognized.\n        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n        //      this can be setup with the `recognizeWith()` method on the recognizer.\n        if (\n          session.stopped !== FORCED_STOP && // 1\n          (!curRecognizer ||\n          recognizer == curRecognizer || // 2\n            recognizer.canRecognizeWith(curRecognizer))\n        ) {\n          // 3\n          recognizer.recognize(inputData);\n        } else {\n          recognizer.reset();\n        }\n\n        // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n        // current active recognizer. but only if we don't already have an active recognizer\n        if (\n          !curRecognizer &&\n          recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)\n        ) {\n          curRecognizer = session.curRecognizer = recognizer;\n        }\n        i++;\n      }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function(recognizer) {\n      if (recognizer instanceof Recognizer) {\n        return recognizer;\n      }\n\n      var recognizers = this.recognizers;\n      for (var i = 0; i < recognizers.length; i++) {\n        if (recognizers[i].options.event == recognizer) {\n          return recognizers[i];\n        }\n      }\n      return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function(recognizer) {\n      if (invokeArrayArg(recognizer, \"add\", this)) {\n        return this;\n      }\n\n      // remove existing\n      var existing = this.get(recognizer.options.event);\n      if (existing) {\n        this.remove(existing);\n      }\n\n      this.recognizers.push(recognizer);\n      recognizer.manager = this;\n\n      return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function(recognizer) {\n      if (invokeArrayArg(recognizer, \"remove\", this)) {\n        return this;\n      }\n\n      recognizer = this.get(recognizer);\n\n      // let's make sure this recognizer exists\n      if (recognizer) {\n        var recognizers = this.recognizers;\n        var index = inArray(recognizers, recognizer);\n\n        if (index !== -1) {\n          recognizers.splice(index, 1);\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function(events, handler) {\n      if (events === undefined) {\n        return;\n      }\n      if (handler === undefined) {\n        return;\n      }\n\n      var handlers = this.handlers;\n      each(splitStr(events), function(event) {\n        handlers[event] = handlers[event] || [];\n        handlers[event].push(handler);\n      });\n      return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function(events, handler) {\n      if (events === undefined) {\n        return;\n      }\n\n      var handlers = this.handlers;\n      each(splitStr(events), function(event) {\n        if (!handler) {\n          delete handlers[event];\n        } else {\n          handlers[event] &&\n            handlers[event].splice(inArray(handlers[event], handler), 1);\n        }\n      });\n      return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function(event, data) {\n      // no handlers, so skip it all\n      console.log(\"eventType: \", event);\n      console.log(\"handlers: \", this.handlers);\n      var handlers = this.handlers[event] && this.handlers[event].slice();\n      if (!handlers || !handlers.length) {\n        return;\n      }\n\n      data.type = event;\n\n      var i = 0;\n      while (i < handlers.length) {\n        handlers[i](data);\n        i++;\n      }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function() {\n      this.handlers = {};\n      this.session = {};\n      this.input.destroy();\n      this.element = null;\n    }\n  };\n\n  assign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n\n    Manager: Manager,\n    Input: Input,\n\n    TouchInput: TouchInput,\n\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn\n  });\n\n  // this prevents errors when Hammer is loaded in the presence of an AMD\n  //  style loader but by script tag, not by the loader.\n  var freeGlobal =\n    typeof window !== \"undefined\"\n      ? window\n      : typeof self !== \"undefined\"\n      ? self\n      : {}; // jshint ignore:line\n  freeGlobal.Hammer = Hammer;\n\n  if (typeof define === \"function\" && define.amd) {\n    define(function() {\n      return Hammer;\n    });\n  } else if (typeof module != \"undefined\" && module.exports) {\n    module.exports = Hammer;\n  } else {\n    window[exportName] = Hammer;\n  }\n})(\"Hammer\");\n"]}