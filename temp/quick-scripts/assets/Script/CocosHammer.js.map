{"version":3,"sources":["CocosHammer.js"],"names":["exportName","undefined","TYPE_FUNCTION","round","Math","abs","now","Date","setTimeoutContext","fn","timeout","context","setTimeout","bindFn","invokeArrayArg","arg","Array","isArray","each","obj","iterator","i","forEach","length","call","hasOwnProperty","deprecate","method","name","message","deprecationMessage","e","Error","stack","replace","log","window","console","warn","apply","arguments","assign","Object","target","TypeError","output","index","source","nextKey","extend","dest","src","merge","keys","inherit","child","base","properties","baseP","prototype","childP","create","constructor","_super","boundFn","boolOrFn","val","args","ifUndefined","val1","val2","addEventListeners","types","handler","splitStr","type","on","removeEventListeners","off","hasParent","node","parent","inStr","str","find","indexOf","trim","split","inArray","findByKey","toArray","slice","uniqueArray","key","sort","results","values","push","sortUniqueArray","a","b","_uniqueId","uniqueId","INPUT_TYPE_TOUCH","COMPUTE_INTERVAL","INPUT_START","INPUT_MOVE","INPUT_END","INPUT_CANCEL","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL","PROPS_XY","Input","manager","callback","self","element","options","inputTarget","nodeHandler","ev","enable","init","evEl","evTarget","destroy","createInputInstance","Type","inputClass","TouchInput","inputHandler","eventType","input","pointersLen","pointers","changedPointersLen","changedPointers","isFirst","isFinal","session","computeInputData","emit","recognize","prevInput","pointersLength","firstInput","simpleCloneInputData","firstMultiple","offsetCenter","center","getCenter","timeStamp","deltaTime","angle","getAngle","distance","getDistance","computeDeltaXY","offsetDirection","getDirection","deltaX","deltaY","overallVelocity","getVelocity","overallVelocityX","x","overallVelocityY","y","scale","angleObj","getRotationByNodePoints","nextAngle","startAngle","rotation","maxPointers","computeIntervalInputData","srcEvent","offset","offsetDelta","prevDelta","last","lastInterval","velocity","velocityX","velocityY","direction","v","p1","p2","props","sqrt","atan2","PI","originPoint","elemenOriginPoint","startPoint","convertToNodeSpaceAR","getStartLocation","endPoint","convertAngle","TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","TOUCH_TARGET_EVENTS","MTEhandler","touchs","getLocation","pointerType","STATE_POSSIBLE","STATE_BEGAN","STATE_CHANGED","STATE_ENDED","STATE_RECOGNIZED","STATE_CANCELLED","STATE_FAILED","Recognizer","defaults","id","state","simultaneous","requireFail","set","recognizeWith","otherRecognizer","getRecognizerByNameIfManager","dropRecognizeWith","requireFailure","dropRequireFailure","splice","hasRequireFailures","canRecognizeWith","event","stateStr","additionalEvent","tryEmit","canEmit","inputData","inputDataClone","reset","process","directionStr","recognizer","get","AttrRecognizer","attrTest","optionPointers","isRecognized","isValid","PanRecognizer","pX","pY","threshold","directionTest","hasMoved","PressRecognizer","_timer","_input","time","validPointers","validMovement","validTime","clearTimeout","RotateRecognizer","SwipeRecognizer","TapRecognizer","pTime","pCenter","count","taps","interval","posThreshold","validTouchTime","failTimeout","validInterval","validMultiTap","tapCount","Hammer","recognizers","preset","Manager","VERSION","STOP","FORCED_STOP","handlers","getPosition","item","add","stop","force","stopped","curRecognizer","existing","remove","events","handlerBound","bind","data","Tap","Pan","Swipe","Rotate","Press","freeGlobal","define","amd","module","exports"],"mappings":"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","file":"CocosHammer.js","sourceRoot":"../../../../assets/Script","sourcesContent":["(function(exportName, undefined) {\n  \"use strict\";\n\n  var TYPE_FUNCTION = \"function\";\n\n  var round = Math.round;\n  var abs = Math.abs;\n  var now = Date.now;\n\n  /**\n   * set a timeout with a given scope\n   * @param {Function} fn\n   * @param {Number} timeout\n   * @param {Object} context\n   * @returns {number}\n   */\n  function setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n  }\n\n  /**\n   * if the argument is an array, we want to execute the fn on each entry\n   * if it aint an array we don't want to do a thing.\n   * this is used by all the methods that accept a single and array argument.\n   * @param {*|Array} arg\n   * @param {String} fn\n   * @param {Object} [context]\n   * @returns {Boolean}\n   */\n  function invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n      each(arg, context[fn], context);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * walk objects and arrays\n   * @param {Object} obj\n   * @param {Function} iterator\n   * @param {Object} context\n   */\n  function each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n      return;\n    }\n\n    if (obj.forEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n      i = 0;\n      while (i < obj.length) {\n        iterator.call(context, obj[i], i, obj);\n        i++;\n      }\n    } else {\n      for (i in obj) {\n        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n      }\n    }\n  }\n\n  /**\n   * wrap a method with a deprecation warning and stack trace\n   * @param {Function} method\n   * @param {String} name\n   * @param {String} message\n   * @returns {Function} A new function wrapping the supplied method.\n   */\n  function deprecate(method, name, message) {\n    var deprecationMessage =\n      \"DEPRECATED METHOD: \" + name + \"\\n\" + message + \" AT \\n\";\n    return function() {\n      var e = new Error(\"get-stack-trace\");\n      var stack =\n        e && e.stack\n          ? e.stack\n              .replace(/^[^\\(]+?[\\n$]/gm, \"\")\n              .replace(/^\\s+at\\s+/gm, \"\")\n              .replace(/^Object.<anonymous>\\s*\\(/gm, \"{anonymous}()@\")\n          : \"Unknown Stack Trace\";\n\n      var log = window.console && (window.console.warn || window.console.log);\n      if (log) {\n        log.call(window.console, deprecationMessage, stack);\n      }\n      return method.apply(this, arguments);\n    };\n  }\n\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} target\n   * @param {...Object} objects_to_assign\n   * @returns {Object} target\n   */\n  var assign;\n  if (typeof Object.assign !== \"function\") {\n    assign = function assign(target) {\n      if (target === undefined || target === null) {\n        throw new TypeError(\"Cannot convert undefined or null to object\");\n      }\n\n      var output = Object(target);\n      for (var index = 1; index < arguments.length; index++) {\n        var source = arguments[index];\n        if (source !== undefined && source !== null) {\n          for (var nextKey in source) {\n            if (source.hasOwnProperty(nextKey)) {\n              output[nextKey] = source[nextKey];\n            }\n          }\n        }\n      }\n      return output;\n    };\n  } else {\n    assign = Object.assign;\n  }\n\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} dest\n   * @param {Object} src\n   * @param {Boolean} [merge=false]\n   * @returns {Object} dest\n   */\n  var extend = deprecate(\n    function extend(dest, src, merge) {\n      var keys = Object.keys(src);\n      var i = 0;\n      while (i < keys.length) {\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\n          dest[keys[i]] = src[keys[i]];\n        }\n        i++;\n      }\n      return dest;\n    },\n    \"extend\",\n    \"Use `assign`.\"\n  );\n\n  /**\n   * merge the values from src in the dest.\n   * means that properties that exist in dest will not be overwritten by src\n   * @param {Object} dest\n   * @param {Object} src\n   * @returns {Object} dest\n   */\n  var merge = deprecate(\n    function merge(dest, src) {\n      return extend(dest, src, true);\n    },\n    \"merge\",\n    \"Use `assign`.\"\n  );\n\n  /**\n   * simple class inheritance\n   * @param {Function} child\n   * @param {Function} base\n   * @param {Object} [properties]\n   */\n  function inherit(child, base, properties) {\n    var baseP = base.prototype,\n      childP;\n\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n      assign(childP, properties);\n    }\n  }\n\n  /**\n   * simple function bind\n   * @param {Function} fn\n   * @param {Object} context\n   * @returns {Function}\n   */\n  function bindFn(fn, context) {\n    return function boundFn() {\n      return fn.apply(context, arguments);\n    };\n  }\n\n  /**\n   * let a boolean value also be a function that must return a boolean\n   * this first item in args will be used as the context\n   * @param {Boolean|Function} val\n   * @param {Array} [args]\n   * @returns {Boolean}\n   */\n  function boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n      return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n  }\n\n  /**\n   * use the val2 when val1 is undefined\n   * @param {*} val1\n   * @param {*} val2\n   * @returns {*}\n   */\n  function ifUndefined(val1, val2) {\n    return val1 === undefined ? val2 : val1;\n  }\n\n  /**\n   * addEventListener with multiple events at once\n   * @param {cc.Node reference cc.EventTarget} target\n   * @param {String} types\n   * @param {Function} handler\n   */\n  function addEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n      target.on(type, handler);\n    });\n  }\n\n  /**\n   * removeEventListener with multiple events at once\n   * @param {cc.Node reference cc.EventTarget} target\n   * @param {cc.Node.EventType} types\n   * @param {Function} handler\n   */\n  function removeEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n      target.off(type, handler);\n    });\n  }\n\n  /**\n   * find if a node is in the given parent\n   * @method hasParent\n   * @param {cc.Node} node\n   * @param {cc.Node} parent\n   * @return {Boolean} found\n   */\n  function hasParent(node, parent) {\n    while (node) {\n      if (node == parent) {\n        return true;\n      }\n      node = node.parent;\n    }\n    return false;\n  }\n\n  /**\n   * small indexOf wrapper\n   * @param {String} str\n   * @param {String} find\n   * @returns {Boolean} found\n   */\n  function inStr(str, find) {\n    return str.indexOf(find) > -1;\n  }\n\n  /**\n   * split string on whitespace\n   * @param {String} str\n   * @returns {Array} words\n   */\n  function splitStr(str) {\n    return str.trim().split(/\\s+/g);\n  }\n\n  /**\n   * find if a array contains the object using indexOf or a simple polyFill\n   * @param {Array} src\n   * @param {String} find\n   * @param {String} [findByKey]\n   * @return {Boolean|Number} false when not found, or the index\n   */\n  function inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n      return src.indexOf(find);\n    } else {\n      var i = 0;\n      while (i < src.length) {\n        if (\n          (findByKey && src[i][findByKey] == find) ||\n          (!findByKey && src[i] === find)\n        ) {\n          return i;\n        }\n        i++;\n      }\n      return -1;\n    }\n  }\n\n  /**\n   * convert array-like objects to real arrays\n   * @param {Object} obj\n   * @returns {Array}\n   */\n  function toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n  }\n\n  /**\n   * unique array with objects based on a key (like 'id') or just by the array's value\n   * @param {Array} src [{id:1},{id:2},{id:1}]\n   * @param {String} [key]\n   * @param {Boolean} [sort=False]\n   * @returns {Array} [{id:1},{id:2}]\n   */\n  function uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n      var val = key ? src[i][key] : src[i];\n      if (inArray(values, val) < 0) {\n        results.push(src[i]);\n      }\n      values[i] = val;\n      i++;\n    }\n\n    if (sort) {\n      if (!key) {\n        results = results.sort();\n      } else {\n        results = results.sort(function sortUniqueArray(a, b) {\n          return a[key] > b[key];\n        });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * get a unique id\n   * @returns {number} uniqueId\n   */\n  var _uniqueId = 1;\n  function uniqueId() {\n    return _uniqueId++;\n  }\n\n  var INPUT_TYPE_TOUCH = \"touch\";\n\n  var COMPUTE_INTERVAL = 25;\n\n  var INPUT_START = 1;\n  var INPUT_MOVE = 2;\n  var INPUT_END = 4;\n  var INPUT_CANCEL = 8;\n\n  var DIRECTION_NONE = 1;\n  var DIRECTION_LEFT = 2;\n  var DIRECTION_RIGHT = 4;\n  var DIRECTION_UP = 8;\n  var DIRECTION_DOWN = 16;\n\n  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\n  var PROPS_XY = [\"x\", \"y\"];\n\n  /**\n   * create new input type manager\n   * @param {Manager} manager\n   * @param {Function} callback\n   * @returns {Input}\n   * @constructor\n   */\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.nodeHandler = function(ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n\n    this.init();\n  }\n\n  Input.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function() {},\n\n    /**\n     * bind the events\n     */\n    init: function() {\n      this.evEl && addEventListeners(this.element, this.evEl, this.nodeHandler);\n      this.evTarget &&\n        addEventListeners(this.target, this.evTarget, this.nodeHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function() {\n      this.evEl &&\n        removeEventListeners(this.element, this.evEl, this.nodeHandler);\n      this.evTarget &&\n        removeEventListeners(this.target, this.evTarget, this.nodeHandler);\n    }\n  };\n\n  /**\n   * create new input type manager\n   * called by the Manager constructor\n   * @param {Hammer} manager\n   * @returns {Input}\n   */\n  function createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n      Type = inputClass;\n    } else {\n      Type = TouchInput;\n    }\n    return new Type(manager, inputHandler);\n  }\n\n  /**\n   * handle input events\n   * @param {Manager} manager\n   * @param {String} eventType\n   * @param {Object} input\n   */\n  function inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst =\n      eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n    var isFinal =\n      eventType & (INPUT_END | INPUT_CANCEL) &&\n      pointersLen - changedPointersLen === 0;\n\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n      manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit(\"hammer.input\", input);\n\n    manager.recognize(input);\n    manager.session.prevInput = input;\n  }\n\n  /**\n   * extend the data with some usable properties like scale, rotate, velocity etc\n   * @param {Object} manager\n   * @param {Object} input\n   */\n  function computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n      session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength === 1) {\n      session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var offsetCenter = firstInput.center;\n    var center = (input.center = getCenter(pointers));\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n    var overallVelocity = getVelocity(\n      input.deltaTime,\n      input.deltaX,\n      input.deltaY\n    );\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity =\n      abs(overallVelocity.x) > abs(overallVelocity.y)\n        ? overallVelocity.x\n        : overallVelocity.y;\n\n    input.scale = 1;\n\n    var angleObj = getRotationByNodePoints(manager, input);\n    var nextAngle = angleObj.nextAngle;\n    var startAngle = angleObj.startAngle;\n    input.rotation = nextAngle - startAngle;\n\n    input.maxPointers = !session.prevInput\n      ? input.pointers.length\n      : input.pointers.length > session.prevInput.maxPointers\n      ? input.pointers.length\n      : session.prevInput.maxPointers;\n\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n      target = input.srcEvent.target;\n    }\n\n    input.target = target;\n  }\n\n  function computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n      prevDelta = session.prevDelta = {\n        x: prevInput.deltaX || 0,\n        y: prevInput.deltaY || 0\n      };\n\n      offset = session.offsetDelta = {\n        x: center.x,\n        y: center.y\n      };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n  }\n\n  /**\n   * velocity is calculated every x ms\n   * @param {Object} session\n   * @param {Object} input\n   */\n  function computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n      deltaTime = input.timeStamp - last.timeStamp,\n      velocity,\n      velocityX,\n      velocityY,\n      direction;\n\n    if (\n      input.eventType != INPUT_CANCEL &&\n      (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)\n    ) {\n      var deltaX = input.deltaX - last.deltaX;\n      var deltaY = input.deltaY - last.deltaY;\n\n      var v = getVelocity(deltaTime, deltaX, deltaY);\n      velocityX = v.x;\n      velocityY = v.y;\n      velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n      direction = getDirection(deltaX, deltaY);\n\n      session.lastInterval = input;\n    } else {\n      // use latest velocity info if it doesn't overtake a minimum period\n      velocity = last.velocity;\n      velocityX = last.velocityX;\n      velocityY = last.velocityY;\n      direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n  }\n\n  /**\n   * create a simple clone from the input used for storage of firstInput\n   * @param {Object} input\n   * @returns {Object} clonedInputData\n   */\n  function simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need XY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n      pointers[i] = {\n        x: round(input.pointers[i].x),\n        y: round(input.pointers[i].y)\n      };\n      i++;\n    }\n\n    return {\n      timeStamp: now(),\n      pointers: pointers,\n      center: getCenter(pointers),\n      deltaX: input.deltaX,\n      deltaY: input.deltaY\n    };\n  }\n\n  /**\n   * get the center of all the pointers\n   * @param {Array} pointers\n   * @return {Object} center contains `x` and `y` properties\n   */\n  function getCenter(pointers) {\n    var pointersLength = pointers.length;\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n      return {\n        x: round(pointers[0].x),\n        y: round(pointers[0].y)\n      };\n    }\n\n    var x = 0,\n      y = 0,\n      i = 0;\n    while (i < pointersLength) {\n      x += pointers[i].x;\n      y += pointers[i].y;\n      i++;\n    }\n\n    return {\n      x: round(x / pointersLength),\n      y: round(y / pointersLength)\n    };\n  }\n\n  /**\n   * calculate the velocity between two points. unit is in px per ms.\n   * @param {Number} deltaTime\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Object} velocity `x` and `y`\n   */\n  function getVelocity(deltaTime, x, y) {\n    return {\n      x: x / deltaTime || 0,\n      y: y / deltaTime || 0\n    };\n  }\n\n  /**\n   * get the direction between two points\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Number} direction\n   */\n  function getDirection(x, y) {\n    if (x === y) {\n      return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n      return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;\n  }\n\n  /**\n   * calculate the absolute distance between two points\n   * @param {Object} p1 {x, y}\n   * @param {Object} p2 {x, y}\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} distance\n   */\n  function getDistance(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n      y = p2[props[1]] - p1[props[1]];\n\n    return Math.sqrt(x * x + y * y);\n  }\n\n  /**\n   * calculate the angle between two coordinates\n   * @param {Object} p1\n   * @param {Object} p2\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} angle\n   */\n  function getAngle(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n      y = p2[props[1]] - p1[props[1]];\n    return (Math.atan2(y, x) * 180) / Math.PI;\n  }\n\n  /**\n   * calculate the rotation degrees when rotate a CC.Node instance\n   * @param {cc.p} originPoint node orgin point\n   * @param {cc.p} startPoint touch start point\n   * @param {cc.p} endPoint touch cancel point\n   * @return {Object} include nextAngle and startAngle\n   */\n  function getRotationByNodePoints(manager, input) {\n    var originPoint = manager.elemenOriginPoint;\n    var startPoint = manager.element.convertToNodeSpaceAR(\n      input.srcEvent.getStartLocation()\n    );\n    var endPoint = manager.element.convertToNodeSpaceAR(input.center);\n    const nextAngle = convertAngle(getAngle(endPoint, originPoint));\n    const startAngle = convertAngle(getAngle(startPoint, originPoint));\n    return {\n      nextAngle,\n      startAngle\n    };\n  }\n\n  /**\n   * convert angle to positive integer, range 0 to 360 degrees\n   * @param {*} angle\n   */\n  function convertAngle(angle) {\n    if (angle <= 90) {\n      return 90 - angle;\n    }\n    return 450 - angle;\n  }\n\n  var TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n  };\n\n  var TOUCH_TARGET_EVENTS = \"touchstart touchmove touchend touchcancel\";\n\n  /**\n   * Multi-user touch events input\n   * @constructor\n   * @extends Input\n   */\n  function TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n\n    Input.apply(this, arguments);\n  }\n\n  inherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n      var type = TOUCH_INPUT_MAP[ev.type];\n      var touchs = [ev.getLocation()];\n      this.callback(this.manager, type, {\n        pointers: touchs,\n        changedPointers: touchs,\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  });\n\n  /**\n   * Recognizer flow explained; *\n   * All recognizers have the initial state of POSSIBLE when a input session starts.\n   * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n   * Example session for mouse-input: mousedown -> mousemove -> mouseup\n   *\n   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n   * which determines with state it should be.\n   *\n   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n   * POSSIBLE to give it another change on the next cycle.\n   *\n   *               Possible\n   *                  |\n   *            +-----+---------------+\n   *            |                     |\n   *      +-----+-----+               |\n   *      |           |               |\n   *   Failed      Cancelled          |\n   *                          +-------+------+\n   *                          |              |\n   *                      Recognized       Began\n   *                                         |\n   *                                      Changed\n   *                                         |\n   *                                  Ended/Recognized\n   */\n  var STATE_POSSIBLE = 1;\n  var STATE_BEGAN = 2;\n  var STATE_CHANGED = 4;\n  var STATE_ENDED = 8;\n  var STATE_RECOGNIZED = STATE_ENDED;\n  var STATE_CANCELLED = 16;\n  var STATE_FAILED = 32;\n\n  /**\n   * Recognizer\n   * Every recognizer needs to extend from this class.\n   * @constructor\n   * @param {Object} options\n   */\n  function Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n\n  Recognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function(options) {\n      assign(this.options, options);\n      return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, \"recognizeWith\", this)) {\n        return this;\n      }\n\n      var simultaneous = this.simultaneous;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      if (!simultaneous[otherRecognizer.id]) {\n        simultaneous[otherRecognizer.id] = otherRecognizer;\n        otherRecognizer.recognizeWith(this);\n      }\n      return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, \"dropRecognizeWith\", this)) {\n        return this;\n      }\n\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      delete this.simultaneous[otherRecognizer.id];\n      return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, \"requireFailure\", this)) {\n        return this;\n      }\n\n      var requireFail = this.requireFail;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      if (inArray(requireFail, otherRecognizer) === -1) {\n        requireFail.push(otherRecognizer);\n        otherRecognizer.requireFailure(this);\n      }\n      return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, \"dropRequireFailure\", this)) {\n        return this;\n      }\n\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      var index = inArray(this.requireFail, otherRecognizer);\n      if (index > -1) {\n        this.requireFail.splice(index, 1);\n      }\n      return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function() {\n      return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function(otherRecognizer) {\n      return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function(input) {\n      var self = this;\n      var state = this.state;\n\n      function emit(event) {\n        self.manager.emit(event, input);\n      }\n\n      // 'panstart' and 'panmove'\n      if (state < STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n\n      emit(self.options.event); // simple 'eventName' events\n\n      if (input.additionalEvent) {\n        // additional event(panleft, panright, pinchin, pinchout...)\n        emit(input.additionalEvent);\n      }\n\n      // panend and pancancel\n      if (state >= STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function(input) {\n      if (this.canEmit()) {\n        return this.emit(input);\n      }\n      // it's failing anyway\n      this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function() {\n      var i = 0;\n      while (i < this.requireFail.length) {\n        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n          return false;\n        }\n        i++;\n      }\n      return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n      // make a new copy of the inputData\n      // so we can change the inputData without messing up the other recognizers\n      var inputDataClone = assign({}, inputData);\n\n      // is is enabled and allow recognizing?\n      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n        this.reset();\n        this.state = STATE_FAILED;\n        return;\n      }\n\n      // reset when we've reached the end\n      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n        this.state = STATE_POSSIBLE;\n      }\n\n      this.state = this.process(inputDataClone);\n\n      // the recognizer has recognized a gesture\n      // so trigger an event\n      if (\n        this.state &\n        (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)\n      ) {\n        this.tryEmit(inputDataClone);\n      }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function(inputData) {}, // jshint ignore:line\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function() {}\n  };\n\n  /**\n   * get a usable string, used as event postfix\n   * @param {Const} state\n   * @returns {String} state\n   */\n  function stateStr(state) {\n    if (state & STATE_CANCELLED) {\n      return \"cancel\";\n    } else if (state & STATE_ENDED) {\n      return \"end\";\n    } else if (state & STATE_CHANGED) {\n      return \"move\";\n    } else if (state & STATE_BEGAN) {\n      return \"start\";\n    }\n    return \"\";\n  }\n\n  /**\n   * direction cons to string\n   * @param {Const} direction\n   * @returns {String}\n   */\n  function directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n      return \"down\";\n    } else if (direction == DIRECTION_UP) {\n      return \"up\";\n    } else if (direction == DIRECTION_LEFT) {\n      return \"left\";\n    } else if (direction == DIRECTION_RIGHT) {\n      return \"right\";\n    }\n    return \"\";\n  }\n\n  /**\n   * get a recognizer by name if it is bound to a manager\n   * @param {Recognizer|String} otherRecognizer\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer}\n   */\n  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n      return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n  }\n\n  /**\n   * This recognizer is just used as a base for the simple attribute recognizers.\n   * @constructor\n   * @extends Recognizer\n   */\n  function AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n  }\n\n  inherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n      /**\n       * @type {Number}\n       * @default 1\n       */\n      pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function(input) {\n      var optionPointers = this.options.pointers;\n      return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function(input) {\n      var state = this.state;\n      var eventType = input.eventType;\n\n      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n      var isValid = this.attrTest(input);\n\n      // on cancel input and we've recognized before, return STATE_CANCELLED\n      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n        return state | STATE_CANCELLED;\n      } else if (isRecognized || isValid) {\n        if (eventType & INPUT_END) {\n          return state | STATE_ENDED;\n        } else if (!(state & STATE_BEGAN)) {\n          return STATE_BEGAN;\n        }\n        return state | STATE_CHANGED;\n      }\n      return STATE_FAILED;\n    }\n  });\n\n  /**\n   * Pan\n   * Recognized when the pointer is down and moved in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n\n    this.pX = null;\n    this.pY = null;\n  }\n\n  inherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n      event: \"pan\",\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    },\n\n    directionTest: function(input) {\n      var options = this.options;\n      var hasMoved = true;\n      var distance = input.distance;\n      var direction = input.direction;\n      var x = input.deltaX;\n      var y = input.deltaY;\n\n      // lock to axis?\n      if (!(direction & options.direction)) {\n        if (options.direction & DIRECTION_HORIZONTAL) {\n          direction =\n            x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n          hasMoved = x != this.pX;\n          distance = Math.abs(input.deltaX);\n        } else {\n          direction =\n            y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n          hasMoved = y != this.pY;\n          distance = Math.abs(input.deltaY);\n        }\n      }\n      input.direction = direction;\n      return (\n        hasMoved &&\n        distance > options.threshold &&\n        direction & options.direction\n      );\n    },\n\n    attrTest: function(input) {\n      return (\n        AttrRecognizer.prototype.attrTest.call(this, input) &&\n        (this.state & STATE_BEGAN ||\n          (!(this.state & STATE_BEGAN) && this.directionTest(input)))\n      );\n    },\n\n    emit: function(input) {\n      this.pX = input.deltaX;\n      this.pY = input.deltaY;\n      var direction = directionStr(input.direction);\n\n      if (direction) {\n        input.additionalEvent = this.options.event + direction;\n      }\n      this._super.emit.call(this, input);\n    }\n  });\n\n  /**\n   * Press\n   * Recognized when the pointer is down for x ms without any movement.\n   * @constructor\n   * @extends Recognizer\n   */\n  function PressRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    this._timer = null;\n    this._input = null;\n  }\n\n  inherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n      event: \"press\",\n      pointers: 1,\n      time: 251, // minimal time of the pointer to be pressed\n      threshold: 9 // a minimal movement is ok, but keep it low\n    },\n\n    process: function(input) {\n      var options = this.options;\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTime = input.deltaTime > options.time;\n\n      this._input = input;\n\n      // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n      if (\n        !validMovement ||\n        !validPointers ||\n        (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)\n      ) {\n        this.reset();\n      } else if (input.eventType & INPUT_START) {\n        this.reset();\n        this._timer = setTimeoutContext(\n          function() {\n            this.state = STATE_RECOGNIZED;\n            this.tryEmit();\n          },\n          options.time,\n          this\n        );\n      } else if (input.eventType & INPUT_END) {\n        return STATE_RECOGNIZED;\n      }\n      return STATE_FAILED;\n    },\n\n    reset: function() {\n      clearTimeout(this._timer);\n    },\n\n    emit: function(input) {\n      if (this.state !== STATE_RECOGNIZED) {\n        return;\n      }\n\n      if (input && input.eventType & INPUT_END) {\n        this.manager.emit(this.options.event + \"up\", input);\n      } else {\n        this._input.timeStamp = now();\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n\n  /**\n   * Rotate\n   * Recognized when two or more pointer are moving in a circular motion.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n      event: \"rotate\",\n      threshold: 0,\n      pointers: 1\n    },\n\n    attrTest: function(input) {\n      return (\n        this._super.attrTest.call(this, input) &&\n        (Math.abs(input.rotation) > this.options.threshold ||\n          this.state & STATE_BEGAN)\n      );\n    }\n  });\n\n  /**\n   * Swipe\n   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n      event: \"swipe\",\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    },\n\n    attrTest: function(input) {\n      var direction = this.options.direction;\n      var velocity;\n\n      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n        velocity = input.overallVelocity;\n      } else if (direction & DIRECTION_HORIZONTAL) {\n        velocity = input.overallVelocityX;\n      } else if (direction & DIRECTION_VERTICAL) {\n        velocity = input.overallVelocityY;\n      }\n\n      return (\n        this._super.attrTest.call(this, input) &&\n        direction & input.offsetDirection &&\n        input.distance > this.options.threshold &&\n        input.maxPointers == this.options.pointers &&\n        abs(velocity) > this.options.velocity &&\n        (input.eventType & INPUT_END || input.eventType & INPUT_CANCEL)\n      );\n    },\n\n    emit: function(input) {\n      var direction = directionStr(input.offsetDirection);\n      if (direction) {\n        this.manager.emit(this.options.event + direction, input);\n      }\n\n      this.manager.emit(this.options.event, input);\n    }\n  });\n\n  /**\n   * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n   * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n   * a single tap.\n   *\n   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n   * multi-taps being recognized.\n   * @constructor\n   * @extends Recognizer\n   */\n  function TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n  }\n\n  inherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof TapRecognizer\n     */\n    defaults: {\n      event: \"tap\",\n      pointers: 1,\n      taps: 1,\n      interval: 300, // max time between the multi-tap taps\n      time: 250, // max time of the pointer to be down (like finger on the screen)\n      threshold: 9, // a minimal movement is ok, but keep it low\n      posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    process: function(input) {\n      var options = this.options;\n\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTouchTime = input.deltaTime < options.time;\n\n      this.reset();\n\n      if (input.eventType & INPUT_START && this.count === 0) {\n        return this.failTimeout();\n      }\n\n      // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n      if (validMovement && validTouchTime && validPointers) {\n        if (input.eventType != INPUT_END) {\n          return this.failTimeout();\n        }\n\n        var validInterval = this.pTime\n          ? input.timeStamp - this.pTime < options.interval\n          : true;\n        var validMultiTap =\n          !this.pCenter ||\n          getDistance(this.pCenter, input.center) < options.posThreshold;\n\n        this.pTime = input.timeStamp;\n        this.pCenter = input.center;\n\n        if (!validMultiTap || !validInterval) {\n          this.count = 1;\n        } else {\n          this.count += 1;\n        }\n\n        this._input = input;\n\n        // if tap count matches we have recognized it,\n        // else it has began recognizing...\n        var tapCount = this.count % options.taps;\n        if (tapCount === 0) {\n          // no failing requirements, immediately trigger the tap event\n          // or wait as long as the multitap interval to trigger\n          if (!this.hasRequireFailures()) {\n            return STATE_RECOGNIZED;\n          } else {\n            this._timer = setTimeoutContext(\n              function() {\n                this.state = STATE_RECOGNIZED;\n                this.tryEmit();\n              },\n              options.interval,\n              this\n            );\n            return STATE_BEGAN;\n          }\n        }\n      }\n      return STATE_FAILED;\n    },\n\n    failTimeout: function() {\n      this._timer = setTimeoutContext(\n        function() {\n          this.state = STATE_FAILED;\n        },\n        this.options.interval,\n        this\n      );\n      return STATE_FAILED;\n    },\n\n    reset: function() {\n      clearTimeout(this._timer);\n    },\n\n    emit: function() {\n      if (this.state == STATE_RECOGNIZED) {\n        this._input.tapCount = this.count;\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n\n  /**\n   * Simple way to create a manager with a default set of recognizers.\n   * @param {cc.Node} element\n   * @param {Object} [options]\n   * @constructor\n   */\n  function Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(\n      options.recognizers,\n      Hammer.defaults.preset\n    );\n    return new Manager(element, options);\n  }\n\n  /**\n   * @const {string}\n   */\n  Hammer.VERSION = \"2.0.8\";\n\n  /**\n   * default settings\n   * @namespace\n   */\n  Hammer.defaults = {\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: TouchInput,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n      // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n      [RotateRecognizer, { enable: true }],\n      [SwipeRecognizer, { direction: DIRECTION_ALL }, [\"rotate\"]],\n      [PanRecognizer, { direction: DIRECTION_ALL }, [\"rotate\"]],\n      [TapRecognizer, {}, [\"rotate\"]],\n      [TapRecognizer, { event: \"doubletap\", taps: 2 }, [\"rotate\"]],\n      [TapRecognizer, { event: \"quadrupletap\", taps: 4 }, [\"rotate\"]],\n      [PressRecognizer, {}, [\"rotate\"]]\n    ]\n  };\n\n  var STOP = 1;\n  var FORCED_STOP = 2;\n\n  /**\n   * Manager\n   * @param {cc.Node} element\n   * @param {Object} [options]\n   * @constructor\n   */\n  function Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n\n    this.element = element;\n    this.elemenOriginPoint = element.getPosition();\n    this.input = createInputInstance(this);\n\n    each(\n      this.options.recognizers,\n      function(item) {\n        var recognizer = this.add(new item[0](item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n      },\n      this\n    );\n  }\n\n  Manager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function(options) {\n      assign(this.options, options);\n\n      if (options.inputTarget) {\n        // Clean up existing event listeners and reinitialize\n        this.input.destroy();\n        this.input.target = options.inputTarget;\n        this.input.init();\n      }\n      return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function(force) {\n      this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n      var session = this.session;\n      if (session.stopped) {\n        return;\n      }\n\n      var recognizer;\n      var recognizers = this.recognizers;\n\n      // this holds the recognizer that is being recognized.\n      // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n      // if no recognizer is detecting a thing, it is set to `null`\n      var curRecognizer = session.curRecognizer;\n\n      // reset when the last recognizer is recognized\n      // or when we're in a new session\n      if (\n        !curRecognizer ||\n        (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)\n      ) {\n        curRecognizer = session.curRecognizer = null;\n      }\n\n      var i = 0;\n      while (i < recognizers.length) {\n        recognizer = recognizers[i];\n\n        // find out if we are allowed try to recognize the input for this one.\n        // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n        //      that is being recognized.\n        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n        //      this can be setup with the `recognizeWith()` method on the recognizer.\n        if (\n          session.stopped !== FORCED_STOP && // 1\n          (!curRecognizer ||\n          recognizer == curRecognizer || // 2\n            recognizer.canRecognizeWith(curRecognizer))\n        ) {\n          // 3\n          recognizer.recognize(inputData);\n        } else {\n          recognizer.reset();\n        }\n\n        // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n        // current active recognizer. but only if we don't already have an active recognizer\n        if (\n          !curRecognizer &&\n          recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)\n        ) {\n          curRecognizer = session.curRecognizer = recognizer;\n        }\n        i++;\n      }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function(recognizer) {\n      if (recognizer instanceof Recognizer) {\n        return recognizer;\n      }\n\n      var recognizers = this.recognizers;\n      for (var i = 0; i < recognizers.length; i++) {\n        if (recognizers[i].options.event == recognizer) {\n          return recognizers[i];\n        }\n      }\n      return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function(recognizer) {\n      if (invokeArrayArg(recognizer, \"add\", this)) {\n        return this;\n      }\n\n      // remove existing\n      var existing = this.get(recognizer.options.event);\n      if (existing) {\n        this.remove(existing);\n      }\n\n      this.recognizers.push(recognizer);\n      recognizer.manager = this;\n\n      return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function(recognizer) {\n      if (invokeArrayArg(recognizer, \"remove\", this)) {\n        return this;\n      }\n\n      recognizer = this.get(recognizer);\n\n      // let's make sure this recognizer exists\n      if (recognizer) {\n        var recognizers = this.recognizers;\n        var index = inArray(recognizers, recognizer);\n\n        if (index !== -1) {\n          recognizers.splice(index, 1);\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @param {Object || Lexical Scope} context\n     * @returns {EventEmitter} this\n     */\n    on: function(events, handler, context, ...args) {\n      if (events === undefined) {\n        return;\n      }\n      if (handler === undefined) {\n        return;\n      }\n\n      var handlers = this.handlers;\n      var handlerBound = handler.bind(context, ...args);\n      each(splitStr(events), function(event) {\n        handlers[event] = handlers[event] || [];\n        handlers[event].push(handlerBound);\n      });\n      return handlerBound;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function(events, handlerBound) {\n      if (events === undefined) {\n        return;\n      }\n\n      var handlers = this.handlers;\n      each(splitStr(events), function(event) {\n        if (!handlerBound) {\n          delete handlers[event];\n        } else {\n          handlers[event] &&\n            handlers[event].splice(inArray(handlers[event], handlerBound), 1);\n        }\n      });\n      return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function(event, data) {\n      // no handlers, so skip it all\n      //   console.log(\"eventType: \", event);\n      //   console.log(\"handlers: \", this.handlers);\n      var handlers = this.handlers[event] && this.handlers[event].slice();\n      if (!handlers || !handlers.length) {\n        return;\n      }\n\n      data.type = event;\n\n      var i = 0;\n      while (i < handlers.length) {\n        handlers[i](data);\n        i++;\n      }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function() {\n      this.handlers = {};\n      this.session = {};\n      this.input.destroy();\n      this.element = null;\n    }\n  };\n\n  assign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n\n    Manager: Manager,\n    Input: Input,\n\n    TouchInput: TouchInput,\n\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn\n  });\n\n  // this prevents errors when Hammer is loaded in the presence of an AMD\n  //  style loader but by script tag, not by the loader.\n  var freeGlobal =\n    typeof window !== \"undefined\"\n      ? window\n      : typeof self !== \"undefined\"\n      ? self\n      : {}; // jshint ignore:line\n  freeGlobal.Hammer = Hammer;\n\n  if (typeof define === \"function\" && define.amd) {\n    define(function() {\n      return Hammer;\n    });\n  } else if (typeof module != \"undefined\" && module.exports) {\n    module.exports = Hammer;\n  }\n})(\"Hammer\");\n"]}