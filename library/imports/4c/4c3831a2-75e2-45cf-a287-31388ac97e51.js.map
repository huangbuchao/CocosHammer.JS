{"version":3,"sources":["../../../../assets/Script/assets/Script/CocosHammer.js"],"names":["exportName","undefined","TYPE_FUNCTION","round","Math","abs","now","Date","setTimeoutContext","fn","timeout","context","setTimeout","bindFn","invokeArrayArg","arg","Array","isArray","each","obj","iterator","i","forEach","length","call","hasOwnProperty","deprecate","method","name","message","deprecationMessage","e","Error","stack","replace","log","window","console","warn","apply","arguments","assign","Object","target","TypeError","output","index","source","nextKey","extend","dest","src","merge","keys","inherit","child","base","properties","baseP","prototype","childP","create","constructor","_super","boundFn","boolOrFn","val","args","ifUndefined","val1","val2","addEventListeners","types","handler","splitStr","type","on","removeEventListeners","off","hasParent","node","parent","inStr","str","find","indexOf","trim","split","inArray","findByKey","toArray","slice","uniqueArray","key","sort","results","values","push","sortUniqueArray","a","b","_uniqueId","uniqueId","INPUT_TYPE_TOUCH","COMPUTE_INTERVAL","INPUT_START","INPUT_MOVE","INPUT_END","INPUT_CANCEL","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL","PROPS_XY","Input","manager","callback","self","element","options","inputTarget","nodeHandler","ev","enable","init","evEl","evTarget","destroy","createInputInstance","Type","inputClass","TouchInput","inputHandler","eventType","input","pointersLen","pointers","changedPointersLen","changedPointers","isFirst","isFinal","session","computeInputData","emit","recognize","prevInput","pointersLength","firstInput","simpleCloneInputData","firstMultiple","offsetCenter","center","getCenter","timeStamp","deltaTime","angle","getAngle","distance","getDistance","computeDeltaXY","offsetDirection","getDirection","deltaX","deltaY","overallVelocity","getVelocity","overallVelocityX","x","overallVelocityY","y","scale","getScale","rotation","getRotation","getRotationByNodePoints","maxPointers","computeIntervalInputData","srcEvent","offset","offsetDelta","prevDelta","last","lastInterval","velocity","velocityX","velocityY","direction","v","p1","p2","props","sqrt","atan2","PI","start","end","originPoint","elemenOriginPoint","startPoint","convertToNodeSpaceAR","getStartLocation","endPoint","nextAngle","convertAngle","startAngle","TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","TOUCH_TARGET_EVENTS","MTEhandler","touchs","getLocation","pointerType","STATE_POSSIBLE","STATE_BEGAN","STATE_CHANGED","STATE_ENDED","STATE_RECOGNIZED","STATE_CANCELLED","STATE_FAILED","Recognizer","defaults","id","state","simultaneous","requireFail","set","recognizeWith","otherRecognizer","getRecognizerByNameIfManager","dropRecognizeWith","requireFailure","dropRequireFailure","splice","hasRequireFailures","canRecognizeWith","event","stateStr","additionalEvent","tryEmit","canEmit","inputData","inputDataClone","reset","process","directionStr","recognizer","get","AttrRecognizer","attrTest","optionPointers","isRecognized","isValid","PanRecognizer","pX","pY","threshold","directionTest","hasMoved","PinchRecognizer","inOut","PressRecognizer","_timer","_input","time","validPointers","validMovement","validTime","clearTimeout","RotateRecognizer","SwipeRecognizer","getTouchAction","TapRecognizer","pTime","pCenter","count","taps","interval","posThreshold","validTouchTime","failTimeout","validInterval","validMultiTap","tapCount","Hammer","recognizers","preset","Manager","VERSION","STOP","FORCED_STOP","handlers","getPosition","item","add","stop","force","stopped","curRecognizer","existing","remove","events","handlerBound","bind","data","Tap","Pan","Swipe","Pinch","Rotate","Press","freeGlobal","define","amd","module","exports"],"mappings":";;;;;;;;AAAA,CAAC,UAASA,UAAT,EAAqBC,SAArB,EAAgC;AAC/B;;AAEA,MAAIC,gBAAgB,UAApB;;AAEA,MAAIC,QAAQC,KAAKD,KAAjB;AACA,MAAIE,MAAMD,KAAKC,GAAf;AACA,MAAIC,MAAMC,KAAKD,GAAf;;AAEA;;;;;;;AAOA,WAASE,iBAAT,CAA2BC,EAA3B,EAA+BC,OAA/B,EAAwCC,OAAxC,EAAiD;AAC/C,WAAOC,WAAWC,OAAOJ,EAAP,EAAWE,OAAX,CAAX,EAAgCD,OAAhC,CAAP;AACD;;AAED;;;;;;;;;AASA,WAASI,cAAT,CAAwBC,GAAxB,EAA6BN,EAA7B,EAAiCE,OAAjC,EAA0C;AACxC,QAAIK,MAAMC,OAAN,CAAcF,GAAd,CAAJ,EAAwB;AACtBG,WAAKH,GAAL,EAAUJ,QAAQF,EAAR,CAAV,EAAuBE,OAAvB;AACA,aAAO,IAAP;AACD;AACD,WAAO,KAAP;AACD;;AAED;;;;;;AAMA,WAASO,IAAT,CAAcC,GAAd,EAAmBC,QAAnB,EAA6BT,OAA7B,EAAsC;AACpC,QAAIU,CAAJ;;AAEA,QAAI,CAACF,GAAL,EAAU;AACR;AACD;;AAED,QAAIA,IAAIG,OAAR,EAAiB;AACfH,UAAIG,OAAJ,CAAYF,QAAZ,EAAsBT,OAAtB;AACD,KAFD,MAEO,IAAIQ,IAAII,MAAJ,KAAetB,SAAnB,EAA8B;AACnCoB,UAAI,CAAJ;AACA,aAAOA,IAAIF,IAAII,MAAf,EAAuB;AACrBH,iBAASI,IAAT,CAAcb,OAAd,EAAuBQ,IAAIE,CAAJ,CAAvB,EAA+BA,CAA/B,EAAkCF,GAAlC;AACAE;AACD;AACF,KANM,MAMA;AACL,WAAKA,CAAL,IAAUF,GAAV,EAAe;AACbA,YAAIM,cAAJ,CAAmBJ,CAAnB,KAAyBD,SAASI,IAAT,CAAcb,OAAd,EAAuBQ,IAAIE,CAAJ,CAAvB,EAA+BA,CAA/B,EAAkCF,GAAlC,CAAzB;AACD;AACF;AACF;;AAED;;;;;;;AAOA,WAASO,SAAT,CAAmBC,MAAnB,EAA2BC,IAA3B,EAAiCC,OAAjC,EAA0C;AACxC,QAAIC,qBACF,wBAAwBF,IAAxB,GAA+B,IAA/B,GAAsCC,OAAtC,GAAgD,QADlD;AAEA,WAAO,YAAW;AAChB,UAAIE,IAAI,IAAIC,KAAJ,CAAU,iBAAV,CAAR;AACA,UAAIC,QACFF,KAAKA,EAAEE,KAAP,GACIF,EAAEE,KAAF,CACGC,OADH,CACW,iBADX,EAC8B,EAD9B,EAEGA,OAFH,CAEW,aAFX,EAE0B,EAF1B,EAGGA,OAHH,CAGW,4BAHX,EAGyC,gBAHzC,CADJ,GAKI,qBANN;;AAQA,UAAIC,MAAMC,OAAOC,OAAP,KAAmBD,OAAOC,OAAP,CAAeC,IAAf,IAAuBF,OAAOC,OAAP,CAAeF,GAAzD,CAAV;AACA,UAAIA,GAAJ,EAAS;AACPA,YAAIX,IAAJ,CAASY,OAAOC,OAAhB,EAAyBP,kBAAzB,EAA6CG,KAA7C;AACD;AACD,aAAON,OAAOY,KAAP,CAAa,IAAb,EAAmBC,SAAnB,CAAP;AACD,KAfD;AAgBD;;AAED;;;;;;;AAOA,MAAIC,MAAJ;AACA,MAAI,OAAOC,OAAOD,MAAd,KAAyB,UAA7B,EAAyC;AACvCA,aAAS,SAASA,MAAT,CAAgBE,MAAhB,EAAwB;AAC/B,UAAIA,WAAW1C,SAAX,IAAwB0C,WAAW,IAAvC,EAA6C;AAC3C,cAAM,IAAIC,SAAJ,CAAc,4CAAd,CAAN;AACD;;AAED,UAAIC,SAASH,OAAOC,MAAP,CAAb;AACA,WAAK,IAAIG,QAAQ,CAAjB,EAAoBA,QAAQN,UAAUjB,MAAtC,EAA8CuB,OAA9C,EAAuD;AACrD,YAAIC,SAASP,UAAUM,KAAV,CAAb;AACA,YAAIC,WAAW9C,SAAX,IAAwB8C,WAAW,IAAvC,EAA6C;AAC3C,eAAK,IAAIC,OAAT,IAAoBD,MAApB,EAA4B;AAC1B,gBAAIA,OAAOtB,cAAP,CAAsBuB,OAAtB,CAAJ,EAAoC;AAClCH,qBAAOG,OAAP,IAAkBD,OAAOC,OAAP,CAAlB;AACD;AACF;AACF;AACF;AACD,aAAOH,MAAP;AACD,KAjBD;AAkBD,GAnBD,MAmBO;AACLJ,aAASC,OAAOD,MAAhB;AACD;;AAED;;;;;;;;AAQA,MAAIQ,SAASvB,UACX,SAASuB,MAAT,CAAgBC,IAAhB,EAAsBC,GAAtB,EAA2BC,KAA3B,EAAkC;AAChC,QAAIC,OAAOX,OAAOW,IAAP,CAAYF,GAAZ,CAAX;AACA,QAAI9B,IAAI,CAAR;AACA,WAAOA,IAAIgC,KAAK9B,MAAhB,EAAwB;AACtB,UAAI,CAAC6B,KAAD,IAAWA,SAASF,KAAKG,KAAKhC,CAAL,CAAL,MAAkBpB,SAA1C,EAAsD;AACpDiD,aAAKG,KAAKhC,CAAL,CAAL,IAAgB8B,IAAIE,KAAKhC,CAAL,CAAJ,CAAhB;AACD;AACDA;AACD;AACD,WAAO6B,IAAP;AACD,GAXU,EAYX,QAZW,EAaX,eAbW,CAAb;;AAgBA;;;;;;;AAOA,MAAIE,QAAQ1B,UACV,SAAS0B,KAAT,CAAeF,IAAf,EAAqBC,GAArB,EAA0B;AACxB,WAAOF,OAAOC,IAAP,EAAaC,GAAb,EAAkB,IAAlB,CAAP;AACD,GAHS,EAIV,OAJU,EAKV,eALU,CAAZ;;AAQA;;;;;;AAMA,WAASG,OAAT,CAAiBC,KAAjB,EAAwBC,IAAxB,EAA8BC,UAA9B,EAA0C;AACxC,QAAIC,QAAQF,KAAKG,SAAjB;AAAA,QACEC,MADF;;AAGAA,aAASL,MAAMI,SAAN,GAAkBjB,OAAOmB,MAAP,CAAcH,KAAd,CAA3B;AACAE,WAAOE,WAAP,GAAqBP,KAArB;AACAK,WAAOG,MAAP,GAAgBL,KAAhB;;AAEA,QAAID,UAAJ,EAAgB;AACdhB,aAAOmB,MAAP,EAAeH,UAAf;AACD;AACF;;AAED;;;;;;AAMA,WAAS5C,MAAT,CAAgBJ,EAAhB,EAAoBE,OAApB,EAA6B;AAC3B,WAAO,SAASqD,OAAT,GAAmB;AACxB,aAAOvD,GAAG8B,KAAH,CAAS5B,OAAT,EAAkB6B,SAAlB,CAAP;AACD,KAFD;AAGD;;AAED;;;;;;;AAOA,WAASyB,QAAT,CAAkBC,GAAlB,EAAuBC,IAAvB,EAA6B;AAC3B,QAAI,QAAOD,GAAP,yCAAOA,GAAP,MAAchE,aAAlB,EAAiC;AAC/B,aAAOgE,IAAI3B,KAAJ,CAAU4B,OAAOA,KAAK,CAAL,KAAWlE,SAAlB,GAA8BA,SAAxC,EAAmDkE,IAAnD,CAAP;AACD;AACD,WAAOD,GAAP;AACD;;AAED;;;;;;AAMA,WAASE,WAAT,CAAqBC,IAArB,EAA2BC,IAA3B,EAAiC;AAC/B,WAAOD,SAASpE,SAAT,GAAqBqE,IAArB,GAA4BD,IAAnC;AACD;;AAED;;;;;;AAMA,WAASE,iBAAT,CAA2B5B,MAA3B,EAAmC6B,KAAnC,EAA0CC,OAA1C,EAAmD;AACjDvD,SAAKwD,SAASF,KAAT,CAAL,EAAsB,UAASG,IAAT,EAAe;AACnChC,aAAOiC,EAAP,CAAUD,IAAV,EAAgBF,OAAhB;AACD,KAFD;AAGD;;AAED;;;;;;AAMA,WAASI,oBAAT,CAA8BlC,MAA9B,EAAsC6B,KAAtC,EAA6CC,OAA7C,EAAsD;AACpDvD,SAAKwD,SAASF,KAAT,CAAL,EAAsB,UAASG,IAAT,EAAe;AACnChC,aAAOmC,GAAP,CAAWH,IAAX,EAAiBF,OAAjB;AACD,KAFD;AAGD;;AAED;;;;;;;AAOA,WAASM,SAAT,CAAmBC,IAAnB,EAAyBC,MAAzB,EAAiC;AAC/B,WAAOD,IAAP,EAAa;AACX,UAAIA,QAAQC,MAAZ,EAAoB;AAClB,eAAO,IAAP;AACD;AACDD,aAAOA,KAAKC,MAAZ;AACD;AACD,WAAO,KAAP;AACD;;AAED;;;;;;AAMA,WAASC,KAAT,CAAeC,GAAf,EAAoBC,IAApB,EAA0B;AACxB,WAAOD,IAAIE,OAAJ,CAAYD,IAAZ,IAAoB,CAAC,CAA5B;AACD;;AAED;;;;;AAKA,WAASV,QAAT,CAAkBS,GAAlB,EAAuB;AACrB,WAAOA,IAAIG,IAAJ,GAAWC,KAAX,CAAiB,MAAjB,CAAP;AACD;;AAED;;;;;;;AAOA,WAASC,OAAT,CAAiBrC,GAAjB,EAAsBiC,IAAtB,EAA4BK,SAA5B,EAAuC;AACrC,QAAItC,IAAIkC,OAAJ,IAAe,CAACI,SAApB,EAA+B;AAC7B,aAAOtC,IAAIkC,OAAJ,CAAYD,IAAZ,CAAP;AACD,KAFD,MAEO;AACL,UAAI/D,IAAI,CAAR;AACA,aAAOA,IAAI8B,IAAI5B,MAAf,EAAuB;AACrB,YACGkE,aAAatC,IAAI9B,CAAJ,EAAOoE,SAAP,KAAqBL,IAAnC,IACC,CAACK,SAAD,IAActC,IAAI9B,CAAJ,MAAW+D,IAF5B,EAGE;AACA,iBAAO/D,CAAP;AACD;AACDA;AACD;AACD,aAAO,CAAC,CAAR;AACD;AACF;;AAED;;;;;AAKA,WAASqE,OAAT,CAAiBvE,GAAjB,EAAsB;AACpB,WAAOH,MAAM2C,SAAN,CAAgBgC,KAAhB,CAAsBnE,IAAtB,CAA2BL,GAA3B,EAAgC,CAAhC,CAAP;AACD;;AAED;;;;;;;AAOA,WAASyE,WAAT,CAAqBzC,GAArB,EAA0B0C,GAA1B,EAA+BC,IAA/B,EAAqC;AACnC,QAAIC,UAAU,EAAd;AACA,QAAIC,SAAS,EAAb;AACA,QAAI3E,IAAI,CAAR;;AAEA,WAAOA,IAAI8B,IAAI5B,MAAf,EAAuB;AACrB,UAAI2C,MAAM2B,MAAM1C,IAAI9B,CAAJ,EAAOwE,GAAP,CAAN,GAAoB1C,IAAI9B,CAAJ,CAA9B;AACA,UAAImE,QAAQQ,MAAR,EAAgB9B,GAAhB,IAAuB,CAA3B,EAA8B;AAC5B6B,gBAAQE,IAAR,CAAa9C,IAAI9B,CAAJ,CAAb;AACD;AACD2E,aAAO3E,CAAP,IAAY6C,GAAZ;AACA7C;AACD;;AAED,QAAIyE,IAAJ,EAAU;AACR,UAAI,CAACD,GAAL,EAAU;AACRE,kBAAUA,QAAQD,IAAR,EAAV;AACD,OAFD,MAEO;AACLC,kBAAUA,QAAQD,IAAR,CAAa,SAASI,eAAT,CAAyBC,CAAzB,EAA4BC,CAA5B,EAA+B;AACpD,iBAAOD,EAAEN,GAAF,IAASO,EAAEP,GAAF,CAAhB;AACD,SAFS,CAAV;AAGD;AACF;;AAED,WAAOE,OAAP;AACD;;AAED;;;;AAIA,MAAIM,YAAY,CAAhB;AACA,WAASC,QAAT,GAAoB;AAClB,WAAOD,WAAP;AACD;;AAED,MAAIE,mBAAmB,OAAvB;;AAEA,MAAIC,mBAAmB,EAAvB;;AAEA,MAAIC,cAAc,CAAlB;AACA,MAAIC,aAAa,CAAjB;AACA,MAAIC,YAAY,CAAhB;AACA,MAAIC,eAAe,CAAnB;;AAEA,MAAIC,iBAAiB,CAArB;AACA,MAAIC,iBAAiB,CAArB;AACA,MAAIC,kBAAkB,CAAtB;AACA,MAAIC,eAAe,CAAnB;AACA,MAAIC,iBAAiB,EAArB;;AAEA,MAAIC,uBAAuBJ,iBAAiBC,eAA5C;AACA,MAAII,qBAAqBH,eAAeC,cAAxC;AACA,MAAIG,gBAAgBF,uBAAuBC,kBAA3C;;AAEA,MAAIE,WAAW,CAAC,GAAD,EAAM,GAAN,CAAf;;AAEA;;;;;;;AAOA,WAASC,KAAT,CAAeC,OAAf,EAAwBC,QAAxB,EAAkC;AAChC,QAAIC,OAAO,IAAX;AACA,SAAKF,OAAL,GAAeA,OAAf;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKE,OAAL,GAAeH,QAAQG,OAAvB;AACA,SAAK/E,MAAL,GAAc4E,QAAQI,OAAR,CAAgBC,WAA9B;;AAEA;AACA;AACA,SAAKC,WAAL,GAAmB,UAASC,EAAT,EAAa;AAC9B,UAAI7D,SAASsD,QAAQI,OAAR,CAAgBI,MAAzB,EAAiC,CAACR,OAAD,CAAjC,CAAJ,EAAiD;AAC/CE,aAAKhD,OAAL,CAAaqD,EAAb;AACD;AACF,KAJD;;AAMA,SAAKE,IAAL;AACD;;AAEDV,QAAM3D,SAAN,GAAkB;AAChB;;;;AAIAc,aAAS,mBAAW,CAAE,CALN;;AAOhB;;;AAGAuD,UAAM,gBAAW;AACf,WAAKC,IAAL,IAAa1D,kBAAkB,KAAKmD,OAAvB,EAAgC,KAAKO,IAArC,EAA2C,KAAKJ,WAAhD,CAAb;AACA,WAAKK,QAAL,IACE3D,kBAAkB,KAAK5B,MAAvB,EAA+B,KAAKuF,QAApC,EAA8C,KAAKL,WAAnD,CADF;AAED,KAde;;AAgBhB;;;AAGAM,aAAS,mBAAW;AAClB,WAAKF,IAAL,IACEpD,qBAAqB,KAAK6C,OAA1B,EAAmC,KAAKO,IAAxC,EAA8C,KAAKJ,WAAnD,CADF;AAEA,WAAKK,QAAL,IACErD,qBAAqB,KAAKlC,MAA1B,EAAkC,KAAKuF,QAAvC,EAAiD,KAAKL,WAAtD,CADF;AAED;AAxBe,GAAlB;;AA2BA;;;;;;AAMA,WAASO,mBAAT,CAA6Bb,OAA7B,EAAsC;AACpC,QAAIc,IAAJ;AACA,QAAIC,aAAaf,QAAQI,OAAR,CAAgBW,UAAjC;;AAEA,QAAIA,UAAJ,EAAgB;AACdD,aAAOC,UAAP;AACD,KAFD,MAEO;AACLD,aAAOE,UAAP;AACD;AACD,WAAO,IAAIF,IAAJ,CAASd,OAAT,EAAkBiB,YAAlB,CAAP;AACD;;AAED;;;;;;AAMA,WAASA,YAAT,CAAsBjB,OAAtB,EAA+BkB,SAA/B,EAA0CC,KAA1C,EAAiD;AAC/C,QAAIC,cAAcD,MAAME,QAAN,CAAerH,MAAjC;AACA,QAAIsH,qBAAqBH,MAAMI,eAAN,CAAsBvH,MAA/C;AACA,QAAIwH,UACFN,YAAYhC,WAAZ,IAA2BkC,cAAcE,kBAAd,KAAqC,CADlE;AAEA,QAAIG,UACFP,aAAa9B,YAAYC,YAAzB,KACA+B,cAAcE,kBAAd,KAAqC,CAFvC;;AAIAH,UAAMK,OAAN,GAAgB,CAAC,CAACA,OAAlB;AACAL,UAAMM,OAAN,GAAgB,CAAC,CAACA,OAAlB;;AAEA,QAAID,OAAJ,EAAa;AACXxB,cAAQ0B,OAAR,GAAkB,EAAlB;AACD;;AAED;AACA;AACAP,UAAMD,SAAN,GAAkBA,SAAlB;;AAEA;AACAS,qBAAiB3B,OAAjB,EAA0BmB,KAA1B;;AAEA;AACAnB,YAAQ4B,IAAR,CAAa,cAAb,EAA6BT,KAA7B;;AAEAnB,YAAQ6B,SAAR,CAAkBV,KAAlB;AACAnB,YAAQ0B,OAAR,CAAgBI,SAAhB,GAA4BX,KAA5B;AACD;;AAED;;;;;AAKA,WAASQ,gBAAT,CAA0B3B,OAA1B,EAAmCmB,KAAnC,EAA0C;AACxC,QAAIO,UAAU1B,QAAQ0B,OAAtB;AACA,QAAIL,WAAWF,MAAME,QAArB;AACA,QAAIU,iBAAiBV,SAASrH,MAA9B;;AAEA;AACA,QAAI,CAAC0H,QAAQM,UAAb,EAAyB;AACvBN,cAAQM,UAAR,GAAqBC,qBAAqBd,KAArB,CAArB;AACD;;AAED;AACA,QAAIY,iBAAiB,CAAjB,IAAsB,CAACL,QAAQQ,aAAnC,EAAkD;AAChDR,cAAQQ,aAAR,GAAwBD,qBAAqBd,KAArB,CAAxB;AACD,KAFD,MAEO,IAAIY,mBAAmB,CAAvB,EAA0B;AAC/BL,cAAQQ,aAAR,GAAwB,KAAxB;AACD;;AAED,QAAIF,aAAaN,QAAQM,UAAzB;AACA,QAAIE,gBAAgBR,QAAQQ,aAA5B;AACA,QAAIC,eAAeD,gBAAgBA,cAAcE,MAA9B,GAAuCJ,WAAWI,MAArE;AACA,QAAIA,SAAUjB,MAAMiB,MAAN,GAAeC,UAAUhB,QAAV,CAA7B;AACAF,UAAMmB,SAAN,GAAkBvJ,KAAlB;AACAoI,UAAMoB,SAAN,GAAkBpB,MAAMmB,SAAN,GAAkBN,WAAWM,SAA/C;;AAEAnB,UAAMqB,KAAN,GAAcC,SAASN,YAAT,EAAuBC,MAAvB,CAAd;AACAjB,UAAMuB,QAAN,GAAiBC,YAAYR,YAAZ,EAA0BC,MAA1B,CAAjB;;AAEAQ,mBAAelB,OAAf,EAAwBP,KAAxB;AACAA,UAAM0B,eAAN,GAAwBC,aAAa3B,MAAM4B,MAAnB,EAA2B5B,MAAM6B,MAAjC,CAAxB;;AAEA,QAAIC,kBAAkBC,YACpB/B,MAAMoB,SADc,EAEpBpB,MAAM4B,MAFc,EAGpB5B,MAAM6B,MAHc,CAAtB;AAKA7B,UAAMgC,gBAAN,GAAyBF,gBAAgBG,CAAzC;AACAjC,UAAMkC,gBAAN,GAAyBJ,gBAAgBK,CAAzC;AACAnC,UAAM8B,eAAN,GACEnK,IAAImK,gBAAgBG,CAApB,IAAyBtK,IAAImK,gBAAgBK,CAApB,CAAzB,GACIL,gBAAgBG,CADpB,GAEIH,gBAAgBK,CAHtB;;AAKAnC,UAAMoC,KAAN,GAAcrB,gBACVsB,SAAStB,cAAcb,QAAvB,EAAiCA,QAAjC,CADU,GAEV,CAFJ;AAGAF,UAAMsC,QAAN,GAAiBvB,gBACbwB,YAAYxB,cAAcb,QAA1B,EAAoCA,QAApC,CADa,GAEbsC,wBAAwB3D,OAAxB,EAAiCmB,KAAjC,CAFJ;;AAIAA,UAAMyC,WAAN,GAAoB,CAAClC,QAAQI,SAAT,GAChBX,MAAME,QAAN,CAAerH,MADC,GAEhBmH,MAAME,QAAN,CAAerH,MAAf,GAAwB0H,QAAQI,SAAR,CAAkB8B,WAA1C,GACAzC,MAAME,QAAN,CAAerH,MADf,GAEA0H,QAAQI,SAAR,CAAkB8B,WAJtB;;AAMAC,6BAAyBnC,OAAzB,EAAkCP,KAAlC;;AAEA;AACA,QAAI/F,SAAS4E,QAAQG,OAArB;AACA,QAAI3C,UAAU2D,MAAM2C,QAAN,CAAe1I,MAAzB,EAAiCA,MAAjC,CAAJ,EAA8C;AAC5CA,eAAS+F,MAAM2C,QAAN,CAAe1I,MAAxB;AACD;;AAED+F,UAAM/F,MAAN,GAAeA,MAAf;AACD;;AAED,WAASwH,cAAT,CAAwBlB,OAAxB,EAAiCP,KAAjC,EAAwC;AACtC,QAAIiB,SAASjB,MAAMiB,MAAnB;AACA,QAAI2B,SAASrC,QAAQsC,WAAR,IAAuB,EAApC;AACA,QAAIC,YAAYvC,QAAQuC,SAAR,IAAqB,EAArC;AACA,QAAInC,YAAYJ,QAAQI,SAAR,IAAqB,EAArC;;AAEA,QAAIX,MAAMD,SAAN,KAAoBhC,WAApB,IAAmC4C,UAAUZ,SAAV,KAAwB9B,SAA/D,EAA0E;AACxE6E,kBAAYvC,QAAQuC,SAAR,GAAoB;AAC9Bb,WAAGtB,UAAUiB,MAAV,IAAoB,CADO;AAE9BO,WAAGxB,UAAUkB,MAAV,IAAoB;AAFO,OAAhC;;AAKAe,eAASrC,QAAQsC,WAAR,GAAsB;AAC7BZ,WAAGhB,OAAOgB,CADmB;AAE7BE,WAAGlB,OAAOkB;AAFmB,OAA/B;AAID;;AAEDnC,UAAM4B,MAAN,GAAekB,UAAUb,CAAV,IAAehB,OAAOgB,CAAP,GAAWW,OAAOX,CAAjC,CAAf;AACAjC,UAAM6B,MAAN,GAAeiB,UAAUX,CAAV,IAAelB,OAAOkB,CAAP,GAAWS,OAAOT,CAAjC,CAAf;AACD;;AAED;;;;;AAKA,WAASO,wBAAT,CAAkCnC,OAAlC,EAA2CP,KAA3C,EAAkD;AAChD,QAAI+C,OAAOxC,QAAQyC,YAAR,IAAwBhD,KAAnC;AAAA,QACEoB,YAAYpB,MAAMmB,SAAN,GAAkB4B,KAAK5B,SADrC;AAAA,QAEE8B,QAFF;AAAA,QAGEC,SAHF;AAAA,QAIEC,SAJF;AAAA,QAKEC,SALF;;AAOA,QACEpD,MAAMD,SAAN,IAAmB7B,YAAnB,KACCkD,YAAYtD,gBAAZ,IAAgCiF,KAAKE,QAAL,KAAkB1L,SADnD,CADF,EAGE;AACA,UAAIqK,SAAS5B,MAAM4B,MAAN,GAAemB,KAAKnB,MAAjC;AACA,UAAIC,SAAS7B,MAAM6B,MAAN,GAAekB,KAAKlB,MAAjC;;AAEA,UAAIwB,IAAItB,YAAYX,SAAZ,EAAuBQ,MAAvB,EAA+BC,MAA/B,CAAR;AACAqB,kBAAYG,EAAEpB,CAAd;AACAkB,kBAAYE,EAAElB,CAAd;AACAc,iBAAWtL,IAAI0L,EAAEpB,CAAN,IAAWtK,IAAI0L,EAAElB,CAAN,CAAX,GAAsBkB,EAAEpB,CAAxB,GAA4BoB,EAAElB,CAAzC;AACAiB,kBAAYzB,aAAaC,MAAb,EAAqBC,MAArB,CAAZ;;AAEAtB,cAAQyC,YAAR,GAAuBhD,KAAvB;AACD,KAdD,MAcO;AACL;AACAiD,iBAAWF,KAAKE,QAAhB;AACAC,kBAAYH,KAAKG,SAAjB;AACAC,kBAAYJ,KAAKI,SAAjB;AACAC,kBAAYL,KAAKK,SAAjB;AACD;;AAEDpD,UAAMiD,QAAN,GAAiBA,QAAjB;AACAjD,UAAMkD,SAAN,GAAkBA,SAAlB;AACAlD,UAAMmD,SAAN,GAAkBA,SAAlB;AACAnD,UAAMoD,SAAN,GAAkBA,SAAlB;AACD;;AAED;;;;;AAKA,WAAStC,oBAAT,CAA8Bd,KAA9B,EAAqC;AACnC;AACA;AACA,QAAIE,WAAW,EAAf;AACA,QAAIvH,IAAI,CAAR;AACA,WAAOA,IAAIqH,MAAME,QAAN,CAAerH,MAA1B,EAAkC;AAChCqH,eAASvH,CAAT,IAAc;AACZsJ,WAAGxK,MAAMuI,MAAME,QAAN,CAAevH,CAAf,EAAkBsJ,CAAxB,CADS;AAEZE,WAAG1K,MAAMuI,MAAME,QAAN,CAAevH,CAAf,EAAkBwJ,CAAxB;AAFS,OAAd;AAIAxJ;AACD;;AAED,WAAO;AACLwI,iBAAWvJ,KADN;AAELsI,gBAAUA,QAFL;AAGLe,cAAQC,UAAUhB,QAAV,CAHH;AAIL0B,cAAQ5B,MAAM4B,MAJT;AAKLC,cAAQ7B,MAAM6B;AALT,KAAP;AAOD;;AAED;;;;;AAKA,WAASX,SAAT,CAAmBhB,QAAnB,EAA6B;AAC3B,QAAIU,iBAAiBV,SAASrH,MAA9B;AACA;AACA,QAAI+H,mBAAmB,CAAvB,EAA0B;AACxB,aAAO;AACLqB,WAAGxK,MAAMyI,SAAS,CAAT,EAAY+B,CAAlB,CADE;AAELE,WAAG1K,MAAMyI,SAAS,CAAT,EAAYiC,CAAlB;AAFE,OAAP;AAID;;AAED,QAAIF,IAAI,CAAR;AAAA,QACEE,IAAI,CADN;AAAA,QAEExJ,IAAI,CAFN;AAGA,WAAOA,IAAIiI,cAAX,EAA2B;AACzBqB,WAAK/B,SAASvH,CAAT,EAAYsJ,CAAjB;AACAE,WAAKjC,SAASvH,CAAT,EAAYwJ,CAAjB;AACAxJ;AACD;;AAED,WAAO;AACLsJ,SAAGxK,MAAMwK,IAAIrB,cAAV,CADE;AAELuB,SAAG1K,MAAM0K,IAAIvB,cAAV;AAFE,KAAP;AAID;;AAED;;;;;;;AAOA,WAASmB,WAAT,CAAqBX,SAArB,EAAgCa,CAAhC,EAAmCE,CAAnC,EAAsC;AACpC,WAAO;AACLF,SAAGA,IAAIb,SAAJ,IAAiB,CADf;AAELe,SAAGA,IAAIf,SAAJ,IAAiB;AAFf,KAAP;AAID;;AAED;;;;;;AAMA,WAASO,YAAT,CAAsBM,CAAtB,EAAyBE,CAAzB,EAA4B;AAC1B,QAAIF,MAAME,CAAV,EAAa;AACX,aAAOhE,cAAP;AACD;;AAED,QAAIxG,IAAIsK,CAAJ,KAAUtK,IAAIwK,CAAJ,CAAd,EAAsB;AACpB,aAAOF,IAAI,CAAJ,GAAQ7D,cAAR,GAAyBC,eAAhC;AACD;AACD,WAAO8D,IAAI,CAAJ,GAAQ7D,YAAR,GAAuBC,cAA9B;AACD;;AAED;;;;;;;AAOA,WAASiD,WAAT,CAAqB8B,EAArB,EAAyBC,EAAzB,EAA6BC,KAA7B,EAAoC;AAClC,QAAI,CAACA,KAAL,EAAY;AACVA,cAAQ7E,QAAR;AACD;AACD,QAAIsD,IAAIsB,GAAGC,MAAM,CAAN,CAAH,IAAeF,GAAGE,MAAM,CAAN,CAAH,CAAvB;AAAA,QACErB,IAAIoB,GAAGC,MAAM,CAAN,CAAH,IAAeF,GAAGE,MAAM,CAAN,CAAH,CADrB;;AAGA,WAAO9L,KAAK+L,IAAL,CAAUxB,IAAIA,CAAJ,GAAQE,IAAIA,CAAtB,CAAP;AACD;;AAED;;;;;;;AAOA,WAASb,QAAT,CAAkBgC,EAAlB,EAAsBC,EAAtB,EAA0BC,KAA1B,EAAiC;AAC/B,QAAI,CAACA,KAAL,EAAY;AACVA,cAAQ7E,QAAR;AACD;AACD,QAAIsD,IAAIsB,GAAGC,MAAM,CAAN,CAAH,IAAeF,GAAGE,MAAM,CAAN,CAAH,CAAvB;AAAA,QACErB,IAAIoB,GAAGC,MAAM,CAAN,CAAH,IAAeF,GAAGE,MAAM,CAAN,CAAH,CADrB;AAEA,WAAQ9L,KAAKgM,KAAL,CAAWvB,CAAX,EAAcF,CAAd,IAAmB,GAApB,GAA2BvK,KAAKiM,EAAvC;AACD;;AAED;;;;;;AAMA,WAASpB,WAAT,CAAqBqB,KAArB,EAA4BC,GAA5B,EAAiC;AAC/B,WACEvC,SAASuC,IAAI,CAAJ,CAAT,EAAiBA,IAAI,CAAJ,CAAjB,EAAyBlF,QAAzB,IACA2C,SAASsC,MAAM,CAAN,CAAT,EAAmBA,MAAM,CAAN,CAAnB,EAA6BjF,QAA7B,CAFF,CAEyC;AAFzC;AAID;;AAED;;;;;;;AAOA,WAAS0D,QAAT,CAAkBuB,KAAlB,EAAyBC,GAAzB,EAA8B;AAC5B,WACErC,YAAYqC,IAAI,CAAJ,CAAZ,EAAoBA,IAAI,CAAJ,CAApB,EAA4BlF,QAA5B,IACA6C,YAAYoC,MAAM,CAAN,CAAZ,EAAsBA,MAAM,CAAN,CAAtB,EAAgCjF,QAAhC,CAFF,CAE4C;AAF5C;AAID;;AAED;;;;;;;AAOA,WAAS6D,uBAAT,CAAiC3D,OAAjC,EAA0CmB,KAA1C,EAAiD;AAC/C,QAAI8D,cAAcjF,QAAQkF,iBAA1B;AACA,QAAIC,aAAanF,QAAQG,OAAR,CAAgBiF,oBAAhB,CACfjE,MAAM2C,QAAN,CAAeuB,gBAAf,EADe,CAAjB;AAGA,QAAIC,WAAWtF,QAAQG,OAAR,CAAgBiF,oBAAhB,CAAqCjE,MAAMiB,MAA3C,CAAf;AACA,QAAMmD,YAAYC,aAAa/C,SAAS6C,QAAT,EAAmBL,WAAnB,CAAb,CAAlB;AACA,QAAMQ,aAAaD,aAAa/C,SAAS0C,UAAT,EAAqBF,WAArB,CAAb,CAAnB;AACA,WAAOM,YAAYE,UAAnB;AACD;;AAED;;;;AAIA,WAASD,YAAT,CAAsBhD,KAAtB,EAA6B;AAC3B,QAAIA,SAAS,EAAb,EAAiB;AACf,aAAO,KAAKA,KAAZ;AACD;AACD,WAAO,MAAMA,KAAb;AACD;;AAED,MAAIkD,kBAAkB;AACpBC,gBAAYzG,WADQ;AAEpB0G,eAAWzG,UAFS;AAGpB0G,cAAUzG,SAHU;AAIpB0G,iBAAazG;AAJO,GAAtB;;AAOA,MAAI0G,sBAAsB,2CAA1B;;AAEA;;;;;AAKA,WAAS/E,UAAT,GAAsB;AACpB,SAAKL,QAAL,GAAgBoF,mBAAhB;;AAEAhG,UAAM/E,KAAN,CAAY,IAAZ,EAAkBC,SAAlB;AACD;;AAEDc,UAAQiF,UAAR,EAAoBjB,KAApB,EAA2B;AACzB7C,aAAS,SAAS8I,UAAT,CAAoBzF,EAApB,EAAwB;AAC/B,UAAInD,OAAOsI,gBAAgBnF,GAAGnD,IAAnB,CAAX;AACA,UAAI6I,SAAS,CAAC1F,GAAG2F,WAAH,EAAD,CAAb;AACA,WAAKjG,QAAL,CAAc,KAAKD,OAAnB,EAA4B5C,IAA5B,EAAkC;AAChCiE,kBAAU4E,MADsB;AAEhC1E,yBAAiB0E,MAFe;AAGhCE,qBAAanH,gBAHmB;AAIhC8E,kBAAUvD;AAJsB,OAAlC;AAMD;AAVwB,GAA3B;;AAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,MAAI6F,iBAAiB,CAArB;AACA,MAAIC,cAAc,CAAlB;AACA,MAAIC,gBAAgB,CAApB;AACA,MAAIC,cAAc,CAAlB;AACA,MAAIC,mBAAmBD,WAAvB;AACA,MAAIE,kBAAkB,EAAtB;AACA,MAAIC,eAAe,EAAnB;;AAEA;;;;;;AAMA,WAASC,UAAT,CAAoBvG,OAApB,EAA6B;AAC3B,SAAKA,OAAL,GAAelF,OAAO,EAAP,EAAW,KAAK0L,QAAhB,EAA0BxG,WAAW,EAArC,CAAf;;AAEA,SAAKyG,EAAL,GAAU9H,UAAV;;AAEA,SAAKiB,OAAL,GAAe,IAAf;;AAEA;AACA,SAAKI,OAAL,CAAaI,MAAb,GAAsB3D,YAAY,KAAKuD,OAAL,CAAaI,MAAzB,EAAiC,IAAjC,CAAtB;;AAEA,SAAKsG,KAAL,GAAaV,cAAb;;AAEA,SAAKW,YAAL,GAAoB,EAApB;AACA,SAAKC,WAAL,GAAmB,EAAnB;AACD;;AAEDL,aAAWvK,SAAX,GAAuB;AACrB;;;;AAIAwK,cAAU,EALW;;AAOrB;;;;;AAKAK,SAAK,aAAS7G,OAAT,EAAkB;AACrBlF,aAAO,KAAKkF,OAAZ,EAAqBA,OAArB;AACA,aAAO,IAAP;AACD,KAfoB;;AAiBrB;;;;;AAKA8G,mBAAe,uBAASC,eAAT,EAA0B;AACvC,UAAI5N,eAAe4N,eAAf,EAAgC,eAAhC,EAAiD,IAAjD,CAAJ,EAA4D;AAC1D,eAAO,IAAP;AACD;;AAED,UAAIJ,eAAe,KAAKA,YAAxB;AACAI,wBAAkBC,6BAA6BD,eAA7B,EAA8C,IAA9C,CAAlB;AACA,UAAI,CAACJ,aAAaI,gBAAgBN,EAA7B,CAAL,EAAuC;AACrCE,qBAAaI,gBAAgBN,EAA7B,IAAmCM,eAAnC;AACAA,wBAAgBD,aAAhB,CAA8B,IAA9B;AACD;AACD,aAAO,IAAP;AACD,KAlCoB;;AAoCrB;;;;;AAKAG,uBAAmB,2BAASF,eAAT,EAA0B;AAC3C,UAAI5N,eAAe4N,eAAf,EAAgC,mBAAhC,EAAqD,IAArD,CAAJ,EAAgE;AAC9D,eAAO,IAAP;AACD;;AAEDA,wBAAkBC,6BAA6BD,eAA7B,EAA8C,IAA9C,CAAlB;AACA,aAAO,KAAKJ,YAAL,CAAkBI,gBAAgBN,EAAlC,CAAP;AACA,aAAO,IAAP;AACD,KAjDoB;;AAmDrB;;;;;AAKAS,oBAAgB,wBAASH,eAAT,EAA0B;AACxC,UAAI5N,eAAe4N,eAAf,EAAgC,gBAAhC,EAAkD,IAAlD,CAAJ,EAA6D;AAC3D,eAAO,IAAP;AACD;;AAED,UAAIH,cAAc,KAAKA,WAAvB;AACAG,wBAAkBC,6BAA6BD,eAA7B,EAA8C,IAA9C,CAAlB;AACA,UAAIlJ,QAAQ+I,WAAR,EAAqBG,eAArB,MAA0C,CAAC,CAA/C,EAAkD;AAChDH,oBAAYtI,IAAZ,CAAiByI,eAAjB;AACAA,wBAAgBG,cAAhB,CAA+B,IAA/B;AACD;AACD,aAAO,IAAP;AACD,KApEoB;;AAsErB;;;;;AAKAC,wBAAoB,4BAASJ,eAAT,EAA0B;AAC5C,UAAI5N,eAAe4N,eAAf,EAAgC,oBAAhC,EAAsD,IAAtD,CAAJ,EAAiE;AAC/D,eAAO,IAAP;AACD;;AAEDA,wBAAkBC,6BAA6BD,eAA7B,EAA8C,IAA9C,CAAlB;AACA,UAAI5L,QAAQ0C,QAAQ,KAAK+I,WAAb,EAA0BG,eAA1B,CAAZ;AACA,UAAI5L,QAAQ,CAAC,CAAb,EAAgB;AACd,aAAKyL,WAAL,CAAiBQ,MAAjB,CAAwBjM,KAAxB,EAA+B,CAA/B;AACD;AACD,aAAO,IAAP;AACD,KAtFoB;;AAwFrB;;;;AAIAkM,wBAAoB,8BAAW;AAC7B,aAAO,KAAKT,WAAL,CAAiBhN,MAAjB,GAA0B,CAAjC;AACD,KA9FoB;;AAgGrB;;;;;AAKA0N,sBAAkB,0BAASP,eAAT,EAA0B;AAC1C,aAAO,CAAC,CAAC,KAAKJ,YAAL,CAAkBI,gBAAgBN,EAAlC,CAAT;AACD,KAvGoB;;AAyGrB;;;;;AAKAjF,UAAM,cAAST,KAAT,EAAgB;AACpB,UAAIjB,OAAO,IAAX;AACA,UAAI4G,QAAQ,KAAKA,KAAjB;;AAEA,eAASlF,IAAT,CAAc+F,KAAd,EAAqB;AACnBzH,aAAKF,OAAL,CAAa4B,IAAb,CAAkB+F,KAAlB,EAAyBxG,KAAzB;AACD;;AAED;AACA,UAAI2F,QAAQP,WAAZ,EAAyB;AACvB3E,aAAK1B,KAAKE,OAAL,CAAauH,KAAb,GAAqBC,SAASd,KAAT,CAA1B;AACD;;AAEDlF,WAAK1B,KAAKE,OAAL,CAAauH,KAAlB,EAboB,CAaM;;AAE1B,UAAIxG,MAAM0G,eAAV,EAA2B;AACzB;AACAjG,aAAKT,MAAM0G,eAAX;AACD;;AAED;AACA,UAAIf,SAASP,WAAb,EAA0B;AACxB3E,aAAK1B,KAAKE,OAAL,CAAauH,KAAb,GAAqBC,SAASd,KAAT,CAA1B;AACD;AACF,KAtIoB;;AAwIrB;;;;;;AAMAgB,aAAS,iBAAS3G,KAAT,EAAgB;AACvB,UAAI,KAAK4G,OAAL,EAAJ,EAAoB;AAClB,eAAO,KAAKnG,IAAL,CAAUT,KAAV,CAAP;AACD;AACD;AACA,WAAK2F,KAAL,GAAaJ,YAAb;AACD,KApJoB;;AAsJrB;;;;AAIAqB,aAAS,mBAAW;AAClB,UAAIjO,IAAI,CAAR;AACA,aAAOA,IAAI,KAAKkN,WAAL,CAAiBhN,MAA5B,EAAoC;AAClC,YAAI,EAAE,KAAKgN,WAAL,CAAiBlN,CAAjB,EAAoBgN,KAApB,IAA6BJ,eAAeN,cAA5C,CAAF,CAAJ,EAAoE;AAClE,iBAAO,KAAP;AACD;AACDtM;AACD;AACD,aAAO,IAAP;AACD,KAnKoB;;AAqKrB;;;;AAIA+H,eAAW,mBAASmG,SAAT,EAAoB;AAC7B;AACA;AACA,UAAIC,iBAAiB/M,OAAO,EAAP,EAAW8M,SAAX,CAArB;;AAEA;AACA,UAAI,CAACtL,SAAS,KAAK0D,OAAL,CAAaI,MAAtB,EAA8B,CAAC,IAAD,EAAOyH,cAAP,CAA9B,CAAL,EAA4D;AAC1D,aAAKC,KAAL;AACA,aAAKpB,KAAL,GAAaJ,YAAb;AACA;AACD;;AAED;AACA,UAAI,KAAKI,KAAL,IAAcN,mBAAmBC,eAAnB,GAAqCC,YAAnD,CAAJ,EAAsE;AACpE,aAAKI,KAAL,GAAaV,cAAb;AACD;;AAED,WAAKU,KAAL,GAAa,KAAKqB,OAAL,CAAaF,cAAb,CAAb;;AAEA;AACA;AACA,UACE,KAAKnB,KAAL,IACCT,cAAcC,aAAd,GAA8BC,WAA9B,GAA4CE,eAD7C,CADF,EAGE;AACA,aAAKqB,OAAL,CAAaG,cAAb;AACD;AACF,KApMoB;;AAsMrB;;;;;;;AAOAE,aAAS,iBAASH,SAAT,EAAoB,CAAE,CA7MV,EA6MY;;AAEjC;;;;;AAKAE,WAAO,iBAAW,CAAE;AApNC,GAAvB;;AAuNA;;;;;AAKA,WAASN,QAAT,CAAkBd,KAAlB,EAAyB;AACvB,QAAIA,QAAQL,eAAZ,EAA6B;AAC3B,aAAO,QAAP;AACD,KAFD,MAEO,IAAIK,QAAQP,WAAZ,EAAyB;AAC9B,aAAO,KAAP;AACD,KAFM,MAEA,IAAIO,QAAQR,aAAZ,EAA2B;AAChC,aAAO,MAAP;AACD,KAFM,MAEA,IAAIQ,QAAQT,WAAZ,EAAyB;AAC9B,aAAO,OAAP;AACD;AACD,WAAO,EAAP;AACD;;AAED;;;;;AAKA,WAAS+B,YAAT,CAAsB7D,SAAtB,EAAiC;AAC/B,QAAIA,aAAa7E,cAAjB,EAAiC;AAC/B,aAAO,MAAP;AACD,KAFD,MAEO,IAAI6E,aAAa9E,YAAjB,EAA+B;AACpC,aAAO,IAAP;AACD,KAFM,MAEA,IAAI8E,aAAahF,cAAjB,EAAiC;AACtC,aAAO,MAAP;AACD,KAFM,MAEA,IAAIgF,aAAa/E,eAAjB,EAAkC;AACvC,aAAO,OAAP;AACD;AACD,WAAO,EAAP;AACD;;AAED;;;;;;AAMA,WAAS4H,4BAAT,CAAsCD,eAAtC,EAAuDkB,UAAvD,EAAmE;AACjE,QAAIrI,UAAUqI,WAAWrI,OAAzB;AACA,QAAIA,OAAJ,EAAa;AACX,aAAOA,QAAQsI,GAAR,CAAYnB,eAAZ,CAAP;AACD;AACD,WAAOA,eAAP;AACD;;AAED;;;;;AAKA,WAASoB,cAAT,GAA0B;AACxB5B,eAAW3L,KAAX,CAAiB,IAAjB,EAAuBC,SAAvB;AACD;;AAEDc,UAAQwM,cAAR,EAAwB5B,UAAxB,EAAoC;AAClC;;;;AAIAC,cAAU;AACR;;;;AAIAvF,gBAAU;AALF,KALwB;;AAalC;;;;;;AAMAmH,cAAU,kBAASrH,KAAT,EAAgB;AACxB,UAAIsH,iBAAiB,KAAKrI,OAAL,CAAaiB,QAAlC;AACA,aAAOoH,mBAAmB,CAAnB,IAAwBtH,MAAME,QAAN,CAAerH,MAAf,KAA0ByO,cAAzD;AACD,KAtBiC;;AAwBlC;;;;;;AAMAN,aAAS,iBAAShH,KAAT,EAAgB;AACvB,UAAI2F,QAAQ,KAAKA,KAAjB;AACA,UAAI5F,YAAYC,MAAMD,SAAtB;;AAEA,UAAIwH,eAAe5B,SAAST,cAAcC,aAAvB,CAAnB;AACA,UAAIqC,UAAU,KAAKH,QAAL,CAAcrH,KAAd,CAAd;;AAEA;AACA,UAAIuH,iBAAiBxH,YAAY7B,YAAZ,IAA4B,CAACsJ,OAA9C,CAAJ,EAA4D;AAC1D,eAAO7B,QAAQL,eAAf;AACD,OAFD,MAEO,IAAIiC,gBAAgBC,OAApB,EAA6B;AAClC,YAAIzH,YAAY9B,SAAhB,EAA2B;AACzB,iBAAO0H,QAAQP,WAAf;AACD,SAFD,MAEO,IAAI,EAAEO,QAAQT,WAAV,CAAJ,EAA4B;AACjC,iBAAOA,WAAP;AACD;AACD,eAAOS,QAAQR,aAAf;AACD;AACD,aAAOI,YAAP;AACD;AAjDiC,GAApC;;AAoDA;;;;;;AAMA,WAASkC,aAAT,GAAyB;AACvBL,mBAAevN,KAAf,CAAqB,IAArB,EAA2BC,SAA3B;;AAEA,SAAK4N,EAAL,GAAU,IAAV;AACA,SAAKC,EAAL,GAAU,IAAV;AACD;;AAED/M,UAAQ6M,aAAR,EAAuBL,cAAvB,EAAuC;AACrC;;;;AAIA3B,cAAU;AACRe,aAAO,KADC;AAERoB,iBAAW,EAFH;AAGR1H,gBAAU,CAHF;AAIRkD,iBAAW1E;AAJH,KAL2B;;AAYrCmJ,mBAAe,uBAAS7H,KAAT,EAAgB;AAC7B,UAAIf,UAAU,KAAKA,OAAnB;AACA,UAAI6I,WAAW,IAAf;AACA,UAAIvG,WAAWvB,MAAMuB,QAArB;AACA,UAAI6B,YAAYpD,MAAMoD,SAAtB;AACA,UAAInB,IAAIjC,MAAM4B,MAAd;AACA,UAAIO,IAAInC,MAAM6B,MAAd;;AAEA;AACA,UAAI,EAAEuB,YAAYnE,QAAQmE,SAAtB,CAAJ,EAAsC;AACpC,YAAInE,QAAQmE,SAAR,GAAoB5E,oBAAxB,EAA8C;AAC5C4E,sBACEnB,MAAM,CAAN,GAAU9D,cAAV,GAA2B8D,IAAI,CAAJ,GAAQ7D,cAAR,GAAyBC,eADtD;AAEAyJ,qBAAW7F,KAAK,KAAKyF,EAArB;AACAnG,qBAAW7J,KAAKC,GAAL,CAASqI,MAAM4B,MAAf,CAAX;AACD,SALD,MAKO;AACLwB,sBACEjB,MAAM,CAAN,GAAUhE,cAAV,GAA2BgE,IAAI,CAAJ,GAAQ7D,YAAR,GAAuBC,cADpD;AAEAuJ,qBAAW3F,KAAK,KAAKwF,EAArB;AACApG,qBAAW7J,KAAKC,GAAL,CAASqI,MAAM6B,MAAf,CAAX;AACD;AACF;AACD7B,YAAMoD,SAAN,GAAkBA,SAAlB;AACA,aACE0E,YACAvG,WAAWtC,QAAQ2I,SADnB,IAEAxE,YAAYnE,QAAQmE,SAHtB;AAKD,KAxCoC;;AA0CrCiE,cAAU,kBAASrH,KAAT,EAAgB;AACxB,aACEoH,eAAenM,SAAf,CAAyBoM,QAAzB,CAAkCvO,IAAlC,CAAuC,IAAvC,EAA6CkH,KAA7C,MACC,KAAK2F,KAAL,GAAaT,WAAb,IACE,EAAE,KAAKS,KAAL,GAAaT,WAAf,KAA+B,KAAK2C,aAAL,CAAmB7H,KAAnB,CAFlC,CADF;AAKD,KAhDoC;;AAkDrCS,UAAM,cAAST,KAAT,EAAgB;AACpB,WAAK0H,EAAL,GAAU1H,MAAM4B,MAAhB;AACA,WAAK+F,EAAL,GAAU3H,MAAM6B,MAAhB;AACA,UAAIuB,YAAY6D,aAAajH,MAAMoD,SAAnB,CAAhB;;AAEA,UAAIA,SAAJ,EAAe;AACbpD,cAAM0G,eAAN,GAAwB,KAAKzH,OAAL,CAAauH,KAAb,GAAqBpD,SAA7C;AACD;AACD,WAAK/H,MAAL,CAAYoF,IAAZ,CAAiB3H,IAAjB,CAAsB,IAAtB,EAA4BkH,KAA5B;AACD;AA3DoC,GAAvC;;AA8DA;;;;;;AAMA,WAAS+H,eAAT,GAA2B;AACzBX,mBAAevN,KAAf,CAAqB,IAArB,EAA2BC,SAA3B;AACD;;AAEDc,UAAQmN,eAAR,EAAyBX,cAAzB,EAAyC;AACvC;;;;AAIA3B,cAAU;AACRe,aAAO,OADC;AAERoB,iBAAW,CAFH;AAGR1H,gBAAU;AAHF,KAL6B;;AAWvCmH,cAAU,kBAASrH,KAAT,EAAgB;AACxB,aACE,KAAK3E,MAAL,CAAYgM,QAAZ,CAAqBvO,IAArB,CAA0B,IAA1B,EAAgCkH,KAAhC,MACCtI,KAAKC,GAAL,CAASqI,MAAMoC,KAAN,GAAc,CAAvB,IAA4B,KAAKnD,OAAL,CAAa2I,SAAzC,IACC,KAAKjC,KAAL,GAAaT,WAFf,CADF;AAKD,KAjBsC;;AAmBvCzE,UAAM,cAAST,KAAT,EAAgB;AACpB,UAAIA,MAAMoC,KAAN,KAAgB,CAApB,EAAuB;AACrB,YAAI4F,QAAQhI,MAAMoC,KAAN,GAAc,CAAd,GAAkB,IAAlB,GAAyB,KAArC;AACApC,cAAM0G,eAAN,GAAwB,KAAKzH,OAAL,CAAauH,KAAb,GAAqBwB,KAA7C;AACD;AACD,WAAK3M,MAAL,CAAYoF,IAAZ,CAAiB3H,IAAjB,CAAsB,IAAtB,EAA4BkH,KAA5B;AACD;AAzBsC,GAAzC;;AA4BA;;;;;;AAMA,WAASiI,eAAT,GAA2B;AACzBzC,eAAW3L,KAAX,CAAiB,IAAjB,EAAuBC,SAAvB;;AAEA,SAAKoO,MAAL,GAAc,IAAd;AACA,SAAKC,MAAL,GAAc,IAAd;AACD;;AAEDvN,UAAQqN,eAAR,EAAyBzC,UAAzB,EAAqC;AACnC;;;;AAIAC,cAAU;AACRe,aAAO,OADC;AAERtG,gBAAU,CAFF;AAGRkI,YAAM,GAHE,EAGG;AACXR,iBAAW,CAJH,CAIK;AAJL,KALyB;;AAYnCZ,aAAS,iBAAShH,KAAT,EAAgB;AACvB,UAAIf,UAAU,KAAKA,OAAnB;AACA,UAAIoJ,gBAAgBrI,MAAME,QAAN,CAAerH,MAAf,KAA0BoG,QAAQiB,QAAtD;AACA,UAAIoI,gBAAgBtI,MAAMuB,QAAN,GAAiBtC,QAAQ2I,SAA7C;AACA,UAAIW,YAAYvI,MAAMoB,SAAN,GAAkBnC,QAAQmJ,IAA1C;;AAEA,WAAKD,MAAL,GAAcnI,KAAd;;AAEA;AACA;AACA,UACE,CAACsI,aAAD,IACA,CAACD,aADD,IAECrI,MAAMD,SAAN,IAAmB9B,YAAYC,YAA/B,KAAgD,CAACqK,SAHpD,EAIE;AACA,aAAKxB,KAAL;AACD,OAND,MAMO,IAAI/G,MAAMD,SAAN,GAAkBhC,WAAtB,EAAmC;AACxC,aAAKgJ,KAAL;AACA,aAAKmB,MAAL,GAAcpQ,kBACZ,YAAW;AACT,eAAK6N,KAAL,GAAaN,gBAAb;AACA,eAAKsB,OAAL;AACD,SAJW,EAKZ1H,QAAQmJ,IALI,EAMZ,IANY,CAAd;AAQD,OAVM,MAUA,IAAIpI,MAAMD,SAAN,GAAkB9B,SAAtB,EAAiC;AACtC,eAAOoH,gBAAP;AACD;AACD,aAAOE,YAAP;AACD,KA1CkC;;AA4CnCwB,WAAO,iBAAW;AAChByB,mBAAa,KAAKN,MAAlB;AACD,KA9CkC;;AAgDnCzH,UAAM,cAAST,KAAT,EAAgB;AACpB,UAAI,KAAK2F,KAAL,KAAeN,gBAAnB,EAAqC;AACnC;AACD;;AAED,UAAIrF,SAASA,MAAMD,SAAN,GAAkB9B,SAA/B,EAA0C;AACxC,aAAKY,OAAL,CAAa4B,IAAb,CAAkB,KAAKxB,OAAL,CAAauH,KAAb,GAAqB,IAAvC,EAA6CxG,KAA7C;AACD,OAFD,MAEO;AACL,aAAKmI,MAAL,CAAYhH,SAAZ,GAAwBvJ,KAAxB;AACA,aAAKiH,OAAL,CAAa4B,IAAb,CAAkB,KAAKxB,OAAL,CAAauH,KAA/B,EAAsC,KAAK2B,MAA3C;AACD;AACF;AA3DkC,GAArC;;AA8DA;;;;;;AAMA,WAASM,gBAAT,GAA4B;AAC1BrB,mBAAevN,KAAf,CAAqB,IAArB,EAA2BC,SAA3B;AACD;;AAEDc,UAAQ6N,gBAAR,EAA0BrB,cAA1B,EAA0C;AACxC;;;;AAIA3B,cAAU;AACRe,aAAO,QADC;AAERoB,iBAAW,CAFH;AAGR1H,gBAAU;AAHF,KAL8B;;AAWxCmH,cAAU,kBAASrH,KAAT,EAAgB;AACxB,aACE,KAAK3E,MAAL,CAAYgM,QAAZ,CAAqBvO,IAArB,CAA0B,IAA1B,EAAgCkH,KAAhC,MACCtI,KAAKC,GAAL,CAASqI,MAAMsC,QAAf,IAA2B,KAAKrD,OAAL,CAAa2I,SAAxC,IACC,KAAKjC,KAAL,GAAaT,WAFf,CADF;AAKD;AAjBuC,GAA1C;;AAoBA;;;;;;AAMA,WAASwD,eAAT,GAA2B;AACzBtB,mBAAevN,KAAf,CAAqB,IAArB,EAA2BC,SAA3B;AACD;;AAEDc,UAAQ8N,eAAR,EAAyBtB,cAAzB,EAAyC;AACvC;;;;AAIA3B,cAAU;AACRe,aAAO,OADC;AAERoB,iBAAW,EAFH;AAGR3E,gBAAU,GAHF;AAIRG,iBAAW5E,uBAAuBC,kBAJ1B;AAKRyB,gBAAU;AALF,KAL6B;;AAavCyI,oBAAgB,0BAAW;AACzB,aAAOlB,cAAcxM,SAAd,CAAwB0N,cAAxB,CAAuC7P,IAAvC,CAA4C,IAA5C,CAAP;AACD,KAfsC;;AAiBvCuO,cAAU,kBAASrH,KAAT,EAAgB;AACxB,UAAIoD,YAAY,KAAKnE,OAAL,CAAamE,SAA7B;AACA,UAAIH,QAAJ;;AAEA,UAAIG,aAAa5E,uBAAuBC,kBAApC,CAAJ,EAA6D;AAC3DwE,mBAAWjD,MAAM8B,eAAjB;AACD,OAFD,MAEO,IAAIsB,YAAY5E,oBAAhB,EAAsC;AAC3CyE,mBAAWjD,MAAMgC,gBAAjB;AACD,OAFM,MAEA,IAAIoB,YAAY3E,kBAAhB,EAAoC;AACzCwE,mBAAWjD,MAAMkC,gBAAjB;AACD;;AAED,aACE,KAAK7G,MAAL,CAAYgM,QAAZ,CAAqBvO,IAArB,CAA0B,IAA1B,EAAgCkH,KAAhC,KACAoD,YAAYpD,MAAM0B,eADlB,IAEA1B,MAAMuB,QAAN,GAAiB,KAAKtC,OAAL,CAAa2I,SAF9B,IAGA5H,MAAMyC,WAAN,IAAqB,KAAKxD,OAAL,CAAaiB,QAHlC,IAIAvI,IAAIsL,QAAJ,IAAgB,KAAKhE,OAAL,CAAagE,QAJ7B,IAKAjD,MAAMD,SAAN,GAAkB9B,SANpB;AAQD,KArCsC;;AAuCvCwC,UAAM,cAAST,KAAT,EAAgB;AACpB,UAAIoD,YAAY6D,aAAajH,MAAM0B,eAAnB,CAAhB;AACA,UAAI0B,SAAJ,EAAe;AACb,aAAKvE,OAAL,CAAa4B,IAAb,CAAkB,KAAKxB,OAAL,CAAauH,KAAb,GAAqBpD,SAAvC,EAAkDpD,KAAlD;AACD;;AAED,WAAKnB,OAAL,CAAa4B,IAAb,CAAkB,KAAKxB,OAAL,CAAauH,KAA/B,EAAsCxG,KAAtC;AACD;AA9CsC,GAAzC;;AAiDA;;;;;;;;;;AAUA,WAAS4I,aAAT,GAAyB;AACvBpD,eAAW3L,KAAX,CAAiB,IAAjB,EAAuBC,SAAvB;;AAEA;AACA;AACA,SAAK+O,KAAL,GAAa,KAAb;AACA,SAAKC,OAAL,GAAe,KAAf;;AAEA,SAAKZ,MAAL,GAAc,IAAd;AACA,SAAKC,MAAL,GAAc,IAAd;AACA,SAAKY,KAAL,GAAa,CAAb;AACD;;AAEDnO,UAAQgO,aAAR,EAAuBpD,UAAvB,EAAmC;AACjC;;;;AAIAC,cAAU;AACRe,aAAO,KADC;AAERtG,gBAAU,CAFF;AAGR8I,YAAM,CAHE;AAIRC,gBAAU,GAJF,EAIO;AACfb,YAAM,GALE,EAKG;AACXR,iBAAW,CANH,EAMM;AACdsB,oBAAc,EAPN,CAOS;AAPT,KALuB;;AAejClC,aAAS,iBAAShH,KAAT,EAAgB;AACvB,UAAIf,UAAU,KAAKA,OAAnB;;AAEA,UAAIoJ,gBAAgBrI,MAAME,QAAN,CAAerH,MAAf,KAA0BoG,QAAQiB,QAAtD;AACA,UAAIoI,gBAAgBtI,MAAMuB,QAAN,GAAiBtC,QAAQ2I,SAA7C;AACA,UAAIuB,iBAAiBnJ,MAAMoB,SAAN,GAAkBnC,QAAQmJ,IAA/C;;AAEA,WAAKrB,KAAL;;AAEA,UAAI/G,MAAMD,SAAN,GAAkBhC,WAAlB,IAAiC,KAAKgL,KAAL,KAAe,CAApD,EAAuD;AACrD,eAAO,KAAKK,WAAL,EAAP;AACD;;AAED;AACA;AACA,UAAId,iBAAiBa,cAAjB,IAAmCd,aAAvC,EAAsD;AACpD,YAAIrI,MAAMD,SAAN,IAAmB9B,SAAvB,EAAkC;AAChC,iBAAO,KAAKmL,WAAL,EAAP;AACD;;AAED,YAAIC,gBAAgB,KAAKR,KAAL,GAChB7I,MAAMmB,SAAN,GAAkB,KAAK0H,KAAvB,GAA+B5J,QAAQgK,QADvB,GAEhB,IAFJ;AAGA,YAAIK,gBACF,CAAC,KAAKR,OAAN,IACAtH,YAAY,KAAKsH,OAAjB,EAA0B9I,MAAMiB,MAAhC,IAA0ChC,QAAQiK,YAFpD;;AAIA,aAAKL,KAAL,GAAa7I,MAAMmB,SAAnB;AACA,aAAK2H,OAAL,GAAe9I,MAAMiB,MAArB;;AAEA,YAAI,CAACqI,aAAD,IAAkB,CAACD,aAAvB,EAAsC;AACpC,eAAKN,KAAL,GAAa,CAAb;AACD,SAFD,MAEO;AACL,eAAKA,KAAL,IAAc,CAAd;AACD;;AAED,aAAKZ,MAAL,GAAcnI,KAAd;;AAEA;AACA;AACA,YAAIuJ,WAAW,KAAKR,KAAL,GAAa9J,QAAQ+J,IAApC;AACA,YAAIO,aAAa,CAAjB,EAAoB;AAClB;AACA;AACA,cAAI,CAAC,KAAKjD,kBAAL,EAAL,EAAgC;AAC9B,mBAAOjB,gBAAP;AACD,WAFD,MAEO;AACL,iBAAK6C,MAAL,GAAcpQ,kBACZ,YAAW;AACT,mBAAK6N,KAAL,GAAaN,gBAAb;AACA,mBAAKsB,OAAL;AACD,aAJW,EAKZ1H,QAAQgK,QALI,EAMZ,IANY,CAAd;AAQA,mBAAO/D,WAAP;AACD;AACF;AACF;AACD,aAAOK,YAAP;AACD,KA3EgC;;AA6EjC6D,iBAAa,uBAAW;AACtB,WAAKlB,MAAL,GAAcpQ,kBACZ,YAAW;AACT,aAAK6N,KAAL,GAAaJ,YAAb;AACD,OAHW,EAIZ,KAAKtG,OAAL,CAAagK,QAJD,EAKZ,IALY,CAAd;AAOA,aAAO1D,YAAP;AACD,KAtFgC;;AAwFjCwB,WAAO,iBAAW;AAChByB,mBAAa,KAAKN,MAAlB;AACD,KA1FgC;;AA4FjCzH,UAAM,gBAAW;AACf,UAAI,KAAKkF,KAAL,IAAcN,gBAAlB,EAAoC;AAClC,aAAK8C,MAAL,CAAYoB,QAAZ,GAAuB,KAAKR,KAA5B;AACA,aAAKlK,OAAL,CAAa4B,IAAb,CAAkB,KAAKxB,OAAL,CAAauH,KAA/B,EAAsC,KAAK2B,MAA3C;AACD;AACF;AAjGgC,GAAnC;;AAoGA;;;;;;AAMA,WAASqB,MAAT,CAAgBxK,OAAhB,EAAyBC,OAAzB,EAAkC;AAChCA,cAAUA,WAAW,EAArB;AACAA,YAAQwK,WAAR,GAAsB/N,YACpBuD,QAAQwK,WADY,EAEpBD,OAAO/D,QAAP,CAAgBiE,MAFI,CAAtB;AAIA,WAAO,IAAIC,OAAJ,CAAY3K,OAAZ,EAAqBC,OAArB,CAAP;AACD;;AAED;;;AAGAuK,SAAOI,OAAP,GAAiB,OAAjB;;AAEA;;;;AAIAJ,SAAO/D,QAAP,GAAkB;AAChB;;;;AAIApG,YAAQ,IALQ;;AAOhB;;;;;;;AAOAH,iBAAa,IAdG;;AAgBhB;;;;;AAKAU,gBAAYC,UArBI;;AAuBhB;;;;;AAKA6J,YAAQ;AACN;AACA,KAACjB,gBAAD,EAAmB,EAAEpJ,QAAQ,IAAV,EAAnB,CAFM,EAGN,CAAC0I,eAAD,EAAkB,EAAE1I,QAAQ,KAAV,EAAlB,EAAqC,CAAC,QAAD,CAArC,CAHM,EAIN,CAACqJ,eAAD,EAAkB,EAAEtF,WAAW5E,oBAAb,EAAlB,CAJM,EAKN,CAACiJ,aAAD,EAAgB,EAAErE,WAAW5E,oBAAb,EAAhB,EAAqD,CAAC,OAAD,CAArD,CALM,EAMN,CAACoK,aAAD,CANM,EAON,CAACA,aAAD,EAAgB,EAAEpC,OAAO,WAAT,EAAsBwC,MAAM,CAA5B,EAAhB,EAAiD,CAAC,KAAD,CAAjD,CAPM,EAQN,CAACf,eAAD,CARM;AA5BQ,GAAlB;;AAwCA,MAAI4B,OAAO,CAAX;AACA,MAAIC,cAAc,CAAlB;;AAEA;;;;;;AAMA,WAASH,OAAT,CAAiB3K,OAAjB,EAA0BC,OAA1B,EAAmC;AACjC,SAAKA,OAAL,GAAelF,OAAO,EAAP,EAAWyP,OAAO/D,QAAlB,EAA4BxG,WAAW,EAAvC,CAAf;;AAEA,SAAKA,OAAL,CAAaC,WAAb,GAA2B,KAAKD,OAAL,CAAaC,WAAb,IAA4BF,OAAvD;;AAEA,SAAK+K,QAAL,GAAgB,EAAhB;AACA,SAAKxJ,OAAL,GAAe,EAAf;AACA,SAAKkJ,WAAL,GAAmB,EAAnB;;AAEA,SAAKzK,OAAL,GAAeA,OAAf;AACA,SAAK+E,iBAAL,GAAyB/E,QAAQgL,WAAR,EAAzB;AACA,SAAKhK,KAAL,GAAaN,oBAAoB,IAApB,CAAb;;AAEAlH,SACE,KAAKyG,OAAL,CAAawK,WADf,EAEE,UAASQ,IAAT,EAAe;AACb,UAAI/C,aAAa,KAAKgD,GAAL,CAAS,IAAID,KAAK,CAAL,CAAJ,CAAYA,KAAK,CAAL,CAAZ,CAAT,CAAjB;AACAA,WAAK,CAAL,KAAW/C,WAAWnB,aAAX,CAAyBkE,KAAK,CAAL,CAAzB,CAAX;AACAA,WAAK,CAAL,KAAW/C,WAAWf,cAAX,CAA0B8D,KAAK,CAAL,CAA1B,CAAX;AACD,KANH,EAOE,IAPF;AASD;;AAEDN,UAAQ1O,SAAR,GAAoB;AAClB;;;;;AAKA6K,SAAK,aAAS7G,OAAT,EAAkB;AACrBlF,aAAO,KAAKkF,OAAZ,EAAqBA,OAArB;;AAEA,UAAIA,QAAQC,WAAZ,EAAyB;AACvB;AACA,aAAKc,KAAL,CAAWP,OAAX;AACA,aAAKO,KAAL,CAAW/F,MAAX,GAAoBgF,QAAQC,WAA5B;AACA,aAAKc,KAAL,CAAWV,IAAX;AACD;AACD,aAAO,IAAP;AACD,KAhBiB;;AAkBlB;;;;;;AAMA6K,UAAM,cAASC,KAAT,EAAgB;AACpB,WAAK7J,OAAL,CAAa8J,OAAb,GAAuBD,QAAQN,WAAR,GAAsBD,IAA7C;AACD,KA1BiB;;AA4BlB;;;;;;AAMAnJ,eAAW,mBAASmG,SAAT,EAAoB;AAC7B,UAAItG,UAAU,KAAKA,OAAnB;AACA,UAAIA,QAAQ8J,OAAZ,EAAqB;AACnB;AACD;;AAED,UAAInD,UAAJ;AACA,UAAIuC,cAAc,KAAKA,WAAvB;;AAEA;AACA;AACA;AACA,UAAIa,gBAAgB/J,QAAQ+J,aAA5B;;AAEA;AACA;AACA,UACE,CAACA,aAAD,IACCA,iBAAiBA,cAAc3E,KAAd,GAAsBN,gBAF1C,EAGE;AACAiF,wBAAgB/J,QAAQ+J,aAAR,GAAwB,IAAxC;AACD;;AAED,UAAI3R,IAAI,CAAR;AACA,aAAOA,IAAI8Q,YAAY5Q,MAAvB,EAA+B;AAC7BqO,qBAAauC,YAAY9Q,CAAZ,CAAb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YACE4H,QAAQ8J,OAAR,KAAoBP,WAApB,MAAmC;AAClC,SAACQ,aAAD,IACDpD,cAAcoD,aADb,IAC8B;AAC7BpD,mBAAWX,gBAAX,CAA4B+D,aAA5B,CAHF,CADF,EAKE;AACA;AACApD,qBAAWxG,SAAX,CAAqBmG,SAArB;AACD,SARD,MAQO;AACLK,qBAAWH,KAAX;AACD;;AAED;AACA;AACA,YACE,CAACuD,aAAD,IACApD,WAAWvB,KAAX,IAAoBT,cAAcC,aAAd,GAA8BC,WAAlD,CAFF,EAGE;AACAkF,0BAAgB/J,QAAQ+J,aAAR,GAAwBpD,UAAxC;AACD;AACDvO;AACD;AACF,KAzFiB;;AA2FlB;;;;;AAKAwO,SAAK,aAASD,UAAT,EAAqB;AACxB,UAAIA,sBAAsB1B,UAA1B,EAAsC;AACpC,eAAO0B,UAAP;AACD;;AAED,UAAIuC,cAAc,KAAKA,WAAvB;AACA,WAAK,IAAI9Q,IAAI,CAAb,EAAgBA,IAAI8Q,YAAY5Q,MAAhC,EAAwCF,GAAxC,EAA6C;AAC3C,YAAI8Q,YAAY9Q,CAAZ,EAAesG,OAAf,CAAuBuH,KAAvB,IAAgCU,UAApC,EAAgD;AAC9C,iBAAOuC,YAAY9Q,CAAZ,CAAP;AACD;AACF;AACD,aAAO,IAAP;AACD,KA5GiB;;AA8GlB;;;;;;AAMAuR,SAAK,aAAShD,UAAT,EAAqB;AACxB,UAAI9O,eAAe8O,UAAf,EAA2B,KAA3B,EAAkC,IAAlC,CAAJ,EAA6C;AAC3C,eAAO,IAAP;AACD;;AAED;AACA,UAAIqD,WAAW,KAAKpD,GAAL,CAASD,WAAWjI,OAAX,CAAmBuH,KAA5B,CAAf;AACA,UAAI+D,QAAJ,EAAc;AACZ,aAAKC,MAAL,CAAYD,QAAZ;AACD;;AAED,WAAKd,WAAL,CAAiBlM,IAAjB,CAAsB2J,UAAtB;AACAA,iBAAWrI,OAAX,GAAqB,IAArB;;AAEA,aAAOqI,UAAP;AACD,KAnIiB;;AAqIlB;;;;;AAKAsD,YAAQ,gBAAStD,UAAT,EAAqB;AAC3B,UAAI9O,eAAe8O,UAAf,EAA2B,QAA3B,EAAqC,IAArC,CAAJ,EAAgD;AAC9C,eAAO,IAAP;AACD;;AAEDA,mBAAa,KAAKC,GAAL,CAASD,UAAT,CAAb;;AAEA;AACA,UAAIA,UAAJ,EAAgB;AACd,YAAIuC,cAAc,KAAKA,WAAvB;AACA,YAAIrP,QAAQ0C,QAAQ2M,WAAR,EAAqBvC,UAArB,CAAZ;;AAEA,YAAI9M,UAAU,CAAC,CAAf,EAAkB;AAChBqP,sBAAYpD,MAAZ,CAAmBjM,KAAnB,EAA0B,CAA1B;AACD;AACF;;AAED,aAAO,IAAP;AACD,KA5JiB;;AA8JlB;;;;;;;AAOA8B,QAAI,YAASuO,MAAT,EAAiB1O,OAAjB,EAA0B9D,OAA1B,EAA4C;AAC9C,UAAIwS,WAAWlT,SAAf,EAA0B;AACxB;AACD;AACD,UAAIwE,YAAYxE,SAAhB,EAA2B;AACzB;AACD;;AAED,UAAIwS,WAAW,KAAKA,QAApB;;AAR8C,wCAANtO,IAAM;AAANA,YAAM;AAAA;;AAS9C,UAAIiP,eAAe3O,QAAQ4O,IAAR,iBAAa1S,OAAb,SAAyBwD,IAAzB,EAAnB;AACAjD,WAAKwD,SAASyO,MAAT,CAAL,EAAuB,UAASjE,KAAT,EAAgB;AACrCuD,iBAASvD,KAAT,IAAkBuD,SAASvD,KAAT,KAAmB,EAArC;AACAuD,iBAASvD,KAAT,EAAgBjJ,IAAhB,CAAqBmN,YAArB;AACD,OAHD;AAIA,aAAOA,YAAP;AACD,KApLiB;;AAsLlB;;;;;;AAMAtO,SAAK,aAASqO,MAAT,EAAiBC,YAAjB,EAA+B;AAClC,UAAID,WAAWlT,SAAf,EAA0B;AACxB;AACD;;AAED,UAAIwS,WAAW,KAAKA,QAApB;AACAvR,WAAKwD,SAASyO,MAAT,CAAL,EAAuB,UAASjE,KAAT,EAAgB;AACrC,YAAI,CAACkE,YAAL,EAAmB;AACjB,iBAAOX,SAASvD,KAAT,CAAP;AACD,SAFD,MAEO;AACLuD,mBAASvD,KAAT,KACEuD,SAASvD,KAAT,EAAgBH,MAAhB,CAAuBvJ,QAAQiN,SAASvD,KAAT,CAAR,EAAyBkE,YAAzB,CAAvB,EAA+D,CAA/D,CADF;AAED;AACF,OAPD;AAQA,aAAO,IAAP;AACD,KA3MiB;;AA6MlB;;;;;AAKAjK,UAAM,cAAS+F,KAAT,EAAgBoE,IAAhB,EAAsB;AAC1B;AACA;AACA;AACA,UAAIb,WAAW,KAAKA,QAAL,CAAcvD,KAAd,KAAwB,KAAKuD,QAAL,CAAcvD,KAAd,EAAqBvJ,KAArB,EAAvC;AACA,UAAI,CAAC8M,QAAD,IAAa,CAACA,SAASlR,MAA3B,EAAmC;AACjC;AACD;;AAED+R,WAAK3O,IAAL,GAAYuK,KAAZ;;AAEA,UAAI7N,IAAI,CAAR;AACA,aAAOA,IAAIoR,SAASlR,MAApB,EAA4B;AAC1BkR,iBAASpR,CAAT,EAAYiS,IAAZ;AACAjS;AACD;AACF,KAlOiB;;AAoOlB;;;;AAIA8G,aAAS,mBAAW;AAClB,WAAKsK,QAAL,GAAgB,EAAhB;AACA,WAAKxJ,OAAL,GAAe,EAAf;AACA,WAAKP,KAAL,CAAWP,OAAX;AACA,WAAKT,OAAL,GAAe,IAAf;AACD;AA7OiB,GAApB;;AAgPAjF,SAAOyP,MAAP,EAAe;AACbzL,iBAAaA,WADA;AAEbC,gBAAYA,UAFC;AAGbC,eAAWA,SAHE;AAIbC,kBAAcA,YAJD;;AAMb+G,oBAAgBA,cANH;AAObC,iBAAaA,WAPA;AAQbC,mBAAeA,aARF;AASbC,iBAAaA,WATA;AAUbC,sBAAkBA,gBAVL;AAWbC,qBAAiBA,eAXJ;AAYbC,kBAAcA,YAZD;;AAcbpH,oBAAgBA,cAdH;AAebC,oBAAgBA,cAfH;AAgBbC,qBAAiBA,eAhBJ;AAiBbC,kBAAcA,YAjBD;AAkBbC,oBAAgBA,cAlBH;AAmBbC,0BAAsBA,oBAnBT;AAoBbC,wBAAoBA,kBApBP;AAqBbC,mBAAeA,aArBF;;AAuBbiL,aAASA,OAvBI;AAwBb/K,WAAOA,KAxBM;;AA0BbiB,gBAAYA,UA1BC;;AA4Bb2F,gBAAYA,UA5BC;AA6Bb4B,oBAAgBA,cA7BH;AA8BbyD,SAAKjC,aA9BQ;AA+BbkC,SAAKrD,aA/BQ;AAgCbsD,WAAOrC,eAhCM;AAiCbsC,WAAOjD,eAjCM;AAkCbkD,YAAQxC,gBAlCK;AAmCbyC,WAAOjD,eAnCM;;AAqCb/L,QAAIL,iBArCS;AAsCbO,SAAKD,oBAtCQ;AAuCb3D,UAAMA,IAvCO;AAwCbkC,WAAOA,KAxCM;AAyCbH,YAAQA,MAzCK;AA0CbR,YAAQA,MA1CK;AA2Cba,aAASA,OA3CI;AA4CbzC,YAAQA;AA5CK,GAAf;;AA+CA;AACA;AACA,MAAIgT,aACF,OAAOzR,MAAP,KAAkB,WAAlB,GACIA,MADJ,GAEI,OAAOqF,IAAP,KAAgB,WAAhB,GACAA,IADA,GAEA,EALN,CA38D+B,CAg9DrB;AACVoM,aAAW3B,MAAX,GAAoBA,MAApB;;AAEA,MAAI,OAAO4B,MAAP,KAAkB,UAAlB,IAAgCA,OAAOC,GAA3C,EAAgD;AAC9CD,WAAO,YAAW;AAChB,aAAO5B,MAAP;AACD,KAFD;AAGD,GAJD,MAIO,IAAI,OAAO8B,MAAP,IAAiB,WAAjB,IAAgCA,OAAOC,OAA3C,EAAoD;AACzDD,WAAOC,OAAP,GAAiB/B,MAAjB;AACD,GAFM,MAEA;AACL9P,WAAOpC,UAAP,IAAqBkS,MAArB;AACD;AACF,CA59DD,EA49DG,QA59DH","file":"CocosHammer.js","sourceRoot":"../../../../assets/Script","sourcesContent":["(function(exportName, undefined) {\n  \"use strict\";\n\n  var TYPE_FUNCTION = \"function\";\n\n  var round = Math.round;\n  var abs = Math.abs;\n  var now = Date.now;\n\n  /**\n   * set a timeout with a given scope\n   * @param {Function} fn\n   * @param {Number} timeout\n   * @param {Object} context\n   * @returns {number}\n   */\n  function setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n  }\n\n  /**\n   * if the argument is an array, we want to execute the fn on each entry\n   * if it aint an array we don't want to do a thing.\n   * this is used by all the methods that accept a single and array argument.\n   * @param {*|Array} arg\n   * @param {String} fn\n   * @param {Object} [context]\n   * @returns {Boolean}\n   */\n  function invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n      each(arg, context[fn], context);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * walk objects and arrays\n   * @param {Object} obj\n   * @param {Function} iterator\n   * @param {Object} context\n   */\n  function each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n      return;\n    }\n\n    if (obj.forEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n      i = 0;\n      while (i < obj.length) {\n        iterator.call(context, obj[i], i, obj);\n        i++;\n      }\n    } else {\n      for (i in obj) {\n        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n      }\n    }\n  }\n\n  /**\n   * wrap a method with a deprecation warning and stack trace\n   * @param {Function} method\n   * @param {String} name\n   * @param {String} message\n   * @returns {Function} A new function wrapping the supplied method.\n   */\n  function deprecate(method, name, message) {\n    var deprecationMessage =\n      \"DEPRECATED METHOD: \" + name + \"\\n\" + message + \" AT \\n\";\n    return function() {\n      var e = new Error(\"get-stack-trace\");\n      var stack =\n        e && e.stack\n          ? e.stack\n              .replace(/^[^\\(]+?[\\n$]/gm, \"\")\n              .replace(/^\\s+at\\s+/gm, \"\")\n              .replace(/^Object.<anonymous>\\s*\\(/gm, \"{anonymous}()@\")\n          : \"Unknown Stack Trace\";\n\n      var log = window.console && (window.console.warn || window.console.log);\n      if (log) {\n        log.call(window.console, deprecationMessage, stack);\n      }\n      return method.apply(this, arguments);\n    };\n  }\n\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} target\n   * @param {...Object} objects_to_assign\n   * @returns {Object} target\n   */\n  var assign;\n  if (typeof Object.assign !== \"function\") {\n    assign = function assign(target) {\n      if (target === undefined || target === null) {\n        throw new TypeError(\"Cannot convert undefined or null to object\");\n      }\n\n      var output = Object(target);\n      for (var index = 1; index < arguments.length; index++) {\n        var source = arguments[index];\n        if (source !== undefined && source !== null) {\n          for (var nextKey in source) {\n            if (source.hasOwnProperty(nextKey)) {\n              output[nextKey] = source[nextKey];\n            }\n          }\n        }\n      }\n      return output;\n    };\n  } else {\n    assign = Object.assign;\n  }\n\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} dest\n   * @param {Object} src\n   * @param {Boolean} [merge=false]\n   * @returns {Object} dest\n   */\n  var extend = deprecate(\n    function extend(dest, src, merge) {\n      var keys = Object.keys(src);\n      var i = 0;\n      while (i < keys.length) {\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\n          dest[keys[i]] = src[keys[i]];\n        }\n        i++;\n      }\n      return dest;\n    },\n    \"extend\",\n    \"Use `assign`.\"\n  );\n\n  /**\n   * merge the values from src in the dest.\n   * means that properties that exist in dest will not be overwritten by src\n   * @param {Object} dest\n   * @param {Object} src\n   * @returns {Object} dest\n   */\n  var merge = deprecate(\n    function merge(dest, src) {\n      return extend(dest, src, true);\n    },\n    \"merge\",\n    \"Use `assign`.\"\n  );\n\n  /**\n   * simple class inheritance\n   * @param {Function} child\n   * @param {Function} base\n   * @param {Object} [properties]\n   */\n  function inherit(child, base, properties) {\n    var baseP = base.prototype,\n      childP;\n\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n      assign(childP, properties);\n    }\n  }\n\n  /**\n   * simple function bind\n   * @param {Function} fn\n   * @param {Object} context\n   * @returns {Function}\n   */\n  function bindFn(fn, context) {\n    return function boundFn() {\n      return fn.apply(context, arguments);\n    };\n  }\n\n  /**\n   * let a boolean value also be a function that must return a boolean\n   * this first item in args will be used as the context\n   * @param {Boolean|Function} val\n   * @param {Array} [args]\n   * @returns {Boolean}\n   */\n  function boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n      return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n  }\n\n  /**\n   * use the val2 when val1 is undefined\n   * @param {*} val1\n   * @param {*} val2\n   * @returns {*}\n   */\n  function ifUndefined(val1, val2) {\n    return val1 === undefined ? val2 : val1;\n  }\n\n  /**\n   * addEventListener with multiple events at once\n   * @param {cc.Node reference cc.EventTarget} target\n   * @param {String} types\n   * @param {Function} handler\n   */\n  function addEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n      target.on(type, handler);\n    });\n  }\n\n  /**\n   * removeEventListener with multiple events at once\n   * @param {cc.Node reference cc.EventTarget} target\n   * @param {cc.Node.EventType} types\n   * @param {Function} handler\n   */\n  function removeEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n      target.off(type, handler);\n    });\n  }\n\n  /**\n   * find if a node is in the given parent\n   * @method hasParent\n   * @param {cc.Node} node\n   * @param {cc.Node} parent\n   * @return {Boolean} found\n   */\n  function hasParent(node, parent) {\n    while (node) {\n      if (node == parent) {\n        return true;\n      }\n      node = node.parent;\n    }\n    return false;\n  }\n\n  /**\n   * small indexOf wrapper\n   * @param {String} str\n   * @param {String} find\n   * @returns {Boolean} found\n   */\n  function inStr(str, find) {\n    return str.indexOf(find) > -1;\n  }\n\n  /**\n   * split string on whitespace\n   * @param {String} str\n   * @returns {Array} words\n   */\n  function splitStr(str) {\n    return str.trim().split(/\\s+/g);\n  }\n\n  /**\n   * find if a array contains the object using indexOf or a simple polyFill\n   * @param {Array} src\n   * @param {String} find\n   * @param {String} [findByKey]\n   * @return {Boolean|Number} false when not found, or the index\n   */\n  function inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n      return src.indexOf(find);\n    } else {\n      var i = 0;\n      while (i < src.length) {\n        if (\n          (findByKey && src[i][findByKey] == find) ||\n          (!findByKey && src[i] === find)\n        ) {\n          return i;\n        }\n        i++;\n      }\n      return -1;\n    }\n  }\n\n  /**\n   * convert array-like objects to real arrays\n   * @param {Object} obj\n   * @returns {Array}\n   */\n  function toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n  }\n\n  /**\n   * unique array with objects based on a key (like 'id') or just by the array's value\n   * @param {Array} src [{id:1},{id:2},{id:1}]\n   * @param {String} [key]\n   * @param {Boolean} [sort=False]\n   * @returns {Array} [{id:1},{id:2}]\n   */\n  function uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n      var val = key ? src[i][key] : src[i];\n      if (inArray(values, val) < 0) {\n        results.push(src[i]);\n      }\n      values[i] = val;\n      i++;\n    }\n\n    if (sort) {\n      if (!key) {\n        results = results.sort();\n      } else {\n        results = results.sort(function sortUniqueArray(a, b) {\n          return a[key] > b[key];\n        });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * get a unique id\n   * @returns {number} uniqueId\n   */\n  var _uniqueId = 1;\n  function uniqueId() {\n    return _uniqueId++;\n  }\n\n  var INPUT_TYPE_TOUCH = \"touch\";\n\n  var COMPUTE_INTERVAL = 25;\n\n  var INPUT_START = 1;\n  var INPUT_MOVE = 2;\n  var INPUT_END = 4;\n  var INPUT_CANCEL = 8;\n\n  var DIRECTION_NONE = 1;\n  var DIRECTION_LEFT = 2;\n  var DIRECTION_RIGHT = 4;\n  var DIRECTION_UP = 8;\n  var DIRECTION_DOWN = 16;\n\n  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\n  var PROPS_XY = [\"x\", \"y\"];\n\n  /**\n   * create new input type manager\n   * @param {Manager} manager\n   * @param {Function} callback\n   * @returns {Input}\n   * @constructor\n   */\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.nodeHandler = function(ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n\n    this.init();\n  }\n\n  Input.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function() {},\n\n    /**\n     * bind the events\n     */\n    init: function() {\n      this.evEl && addEventListeners(this.element, this.evEl, this.nodeHandler);\n      this.evTarget &&\n        addEventListeners(this.target, this.evTarget, this.nodeHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function() {\n      this.evEl &&\n        removeEventListeners(this.element, this.evEl, this.nodeHandler);\n      this.evTarget &&\n        removeEventListeners(this.target, this.evTarget, this.nodeHandler);\n    }\n  };\n\n  /**\n   * create new input type manager\n   * called by the Manager constructor\n   * @param {Hammer} manager\n   * @returns {Input}\n   */\n  function createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n      Type = inputClass;\n    } else {\n      Type = TouchInput;\n    }\n    return new Type(manager, inputHandler);\n  }\n\n  /**\n   * handle input events\n   * @param {Manager} manager\n   * @param {String} eventType\n   * @param {Object} input\n   */\n  function inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst =\n      eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n    var isFinal =\n      eventType & (INPUT_END | INPUT_CANCEL) &&\n      pointersLen - changedPointersLen === 0;\n\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n      manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit(\"hammer.input\", input);\n\n    manager.recognize(input);\n    manager.session.prevInput = input;\n  }\n\n  /**\n   * extend the data with some usable properties like scale, rotate, velocity etc\n   * @param {Object} manager\n   * @param {Object} input\n   */\n  function computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n      session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n      session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n      session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n    var center = (input.center = getCenter(pointers));\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n    var overallVelocity = getVelocity(\n      input.deltaTime,\n      input.deltaX,\n      input.deltaY\n    );\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity =\n      abs(overallVelocity.x) > abs(overallVelocity.y)\n        ? overallVelocity.x\n        : overallVelocity.y;\n\n    input.scale = firstMultiple\n      ? getScale(firstMultiple.pointers, pointers)\n      : 1;\n    input.rotation = firstMultiple\n      ? getRotation(firstMultiple.pointers, pointers)\n      : getRotationByNodePoints(manager, input);\n\n    input.maxPointers = !session.prevInput\n      ? input.pointers.length\n      : input.pointers.length > session.prevInput.maxPointers\n      ? input.pointers.length\n      : session.prevInput.maxPointers;\n\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n      target = input.srcEvent.target;\n    }\n\n    input.target = target;\n  }\n\n  function computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n      prevDelta = session.prevDelta = {\n        x: prevInput.deltaX || 0,\n        y: prevInput.deltaY || 0\n      };\n\n      offset = session.offsetDelta = {\n        x: center.x,\n        y: center.y\n      };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n  }\n\n  /**\n   * velocity is calculated every x ms\n   * @param {Object} session\n   * @param {Object} input\n   */\n  function computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n      deltaTime = input.timeStamp - last.timeStamp,\n      velocity,\n      velocityX,\n      velocityY,\n      direction;\n\n    if (\n      input.eventType != INPUT_CANCEL &&\n      (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)\n    ) {\n      var deltaX = input.deltaX - last.deltaX;\n      var deltaY = input.deltaY - last.deltaY;\n\n      var v = getVelocity(deltaTime, deltaX, deltaY);\n      velocityX = v.x;\n      velocityY = v.y;\n      velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n      direction = getDirection(deltaX, deltaY);\n\n      session.lastInterval = input;\n    } else {\n      // use latest velocity info if it doesn't overtake a minimum period\n      velocity = last.velocity;\n      velocityX = last.velocityX;\n      velocityY = last.velocityY;\n      direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n  }\n\n  /**\n   * create a simple clone from the input used for storage of firstInput and firstMultiple\n   * @param {Object} input\n   * @returns {Object} clonedInputData\n   */\n  function simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need XY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n      pointers[i] = {\n        x: round(input.pointers[i].x),\n        y: round(input.pointers[i].y)\n      };\n      i++;\n    }\n\n    return {\n      timeStamp: now(),\n      pointers: pointers,\n      center: getCenter(pointers),\n      deltaX: input.deltaX,\n      deltaY: input.deltaY\n    };\n  }\n\n  /**\n   * get the center of all the pointers\n   * @param {Array} pointers\n   * @return {Object} center contains `x` and `y` properties\n   */\n  function getCenter(pointers) {\n    var pointersLength = pointers.length;\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n      return {\n        x: round(pointers[0].x),\n        y: round(pointers[0].y)\n      };\n    }\n\n    var x = 0,\n      y = 0,\n      i = 0;\n    while (i < pointersLength) {\n      x += pointers[i].x;\n      y += pointers[i].y;\n      i++;\n    }\n\n    return {\n      x: round(x / pointersLength),\n      y: round(y / pointersLength)\n    };\n  }\n\n  /**\n   * calculate the velocity between two points. unit is in px per ms.\n   * @param {Number} deltaTime\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Object} velocity `x` and `y`\n   */\n  function getVelocity(deltaTime, x, y) {\n    return {\n      x: x / deltaTime || 0,\n      y: y / deltaTime || 0\n    };\n  }\n\n  /**\n   * get the direction between two points\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Number} direction\n   */\n  function getDirection(x, y) {\n    if (x === y) {\n      return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n      return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;\n  }\n\n  /**\n   * calculate the absolute distance between two points\n   * @param {Object} p1 {x, y}\n   * @param {Object} p2 {x, y}\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} distance\n   */\n  function getDistance(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n      y = p2[props[1]] - p1[props[1]];\n\n    return Math.sqrt(x * x + y * y);\n  }\n\n  /**\n   * calculate the angle between two coordinates\n   * @param {Object} p1\n   * @param {Object} p2\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} angle\n   */\n  function getAngle(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n      y = p2[props[1]] - p1[props[1]];\n    return (Math.atan2(y, x) * 180) / Math.PI;\n  }\n\n  /**\n   * calculate the rotation degrees between two pointersets\n   * @param {Array} start array of pointers\n   * @param {Array} end array of pointers\n   * @return {Number} rotation\n   */\n  function getRotation(start, end) {\n    return (\n      getAngle(end[1], end[0], PROPS_XY) +\n      getAngle(start[1], start[0], PROPS_XY) //modified clientX -> x\n    );\n  }\n\n  /**\n   * calculate the scale factor between two pointersets\n   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n   * @param {Array} start array of pointers\n   * @param {Array} end array of pointers\n   * @return {Number} scale\n   */\n  function getScale(start, end) {\n    return (\n      getDistance(end[0], end[1], PROPS_XY) /\n      getDistance(start[0], start[1], PROPS_XY) //modified clientX -> x\n    );\n  }\n\n  /**\n   * calculate the rotation degrees when rotate a CC.Node instance\n   * @param {cc.p} originPoint node orgin point\n   * @param {cc.p} startPoint touch start point\n   * @param {cc.p} endPoint touch cancel point\n   * @return {Object} include nextAngle and startAngle\n   */\n  function getRotationByNodePoints(manager, input) {\n    var originPoint = manager.elemenOriginPoint;\n    var startPoint = manager.element.convertToNodeSpaceAR(\n      input.srcEvent.getStartLocation()\n    );\n    var endPoint = manager.element.convertToNodeSpaceAR(input.center);\n    const nextAngle = convertAngle(getAngle(endPoint, originPoint));\n    const startAngle = convertAngle(getAngle(startPoint, originPoint));\n    return nextAngle - startAngle;\n  }\n\n  /**\n   * convert angle to positive integer, range 0 to 360 degrees\n   * @param {*} angle\n   */\n  function convertAngle(angle) {\n    if (angle <= 90) {\n      return 90 - angle;\n    }\n    return 450 - angle;\n  }\n\n  var TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n  };\n\n  var TOUCH_TARGET_EVENTS = \"touchstart touchmove touchend touchcancel\";\n\n  /**\n   * Multi-user touch events input\n   * @constructor\n   * @extends Input\n   */\n  function TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n\n    Input.apply(this, arguments);\n  }\n\n  inherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n      var type = TOUCH_INPUT_MAP[ev.type];\n      var touchs = [ev.getLocation()];\n      this.callback(this.manager, type, {\n        pointers: touchs,\n        changedPointers: touchs,\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  });\n\n  /**\n   * Recognizer flow explained; *\n   * All recognizers have the initial state of POSSIBLE when a input session starts.\n   * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n   * Example session for mouse-input: mousedown -> mousemove -> mouseup\n   *\n   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n   * which determines with state it should be.\n   *\n   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n   * POSSIBLE to give it another change on the next cycle.\n   *\n   *               Possible\n   *                  |\n   *            +-----+---------------+\n   *            |                     |\n   *      +-----+-----+               |\n   *      |           |               |\n   *   Failed      Cancelled          |\n   *                          +-------+------+\n   *                          |              |\n   *                      Recognized       Began\n   *                                         |\n   *                                      Changed\n   *                                         |\n   *                                  Ended/Recognized\n   */\n  var STATE_POSSIBLE = 1;\n  var STATE_BEGAN = 2;\n  var STATE_CHANGED = 4;\n  var STATE_ENDED = 8;\n  var STATE_RECOGNIZED = STATE_ENDED;\n  var STATE_CANCELLED = 16;\n  var STATE_FAILED = 32;\n\n  /**\n   * Recognizer\n   * Every recognizer needs to extend from this class.\n   * @constructor\n   * @param {Object} options\n   */\n  function Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n\n  Recognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function(options) {\n      assign(this.options, options);\n      return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, \"recognizeWith\", this)) {\n        return this;\n      }\n\n      var simultaneous = this.simultaneous;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      if (!simultaneous[otherRecognizer.id]) {\n        simultaneous[otherRecognizer.id] = otherRecognizer;\n        otherRecognizer.recognizeWith(this);\n      }\n      return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, \"dropRecognizeWith\", this)) {\n        return this;\n      }\n\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      delete this.simultaneous[otherRecognizer.id];\n      return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, \"requireFailure\", this)) {\n        return this;\n      }\n\n      var requireFail = this.requireFail;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      if (inArray(requireFail, otherRecognizer) === -1) {\n        requireFail.push(otherRecognizer);\n        otherRecognizer.requireFailure(this);\n      }\n      return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, \"dropRequireFailure\", this)) {\n        return this;\n      }\n\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      var index = inArray(this.requireFail, otherRecognizer);\n      if (index > -1) {\n        this.requireFail.splice(index, 1);\n      }\n      return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function() {\n      return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function(otherRecognizer) {\n      return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function(input) {\n      var self = this;\n      var state = this.state;\n\n      function emit(event) {\n        self.manager.emit(event, input);\n      }\n\n      // 'panstart' and 'panmove'\n      if (state < STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n\n      emit(self.options.event); // simple 'eventName' events\n\n      if (input.additionalEvent) {\n        // additional event(panleft, panright, pinchin, pinchout...)\n        emit(input.additionalEvent);\n      }\n\n      // panend and pancancel\n      if (state >= STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function(input) {\n      if (this.canEmit()) {\n        return this.emit(input);\n      }\n      // it's failing anyway\n      this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function() {\n      var i = 0;\n      while (i < this.requireFail.length) {\n        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n          return false;\n        }\n        i++;\n      }\n      return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n      // make a new copy of the inputData\n      // so we can change the inputData without messing up the other recognizers\n      var inputDataClone = assign({}, inputData);\n\n      // is is enabled and allow recognizing?\n      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n        this.reset();\n        this.state = STATE_FAILED;\n        return;\n      }\n\n      // reset when we've reached the end\n      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n        this.state = STATE_POSSIBLE;\n      }\n\n      this.state = this.process(inputDataClone);\n\n      // the recognizer has recognized a gesture\n      // so trigger an event\n      if (\n        this.state &\n        (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)\n      ) {\n        this.tryEmit(inputDataClone);\n      }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function(inputData) {}, // jshint ignore:line\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function() {}\n  };\n\n  /**\n   * get a usable string, used as event postfix\n   * @param {Const} state\n   * @returns {String} state\n   */\n  function stateStr(state) {\n    if (state & STATE_CANCELLED) {\n      return \"cancel\";\n    } else if (state & STATE_ENDED) {\n      return \"end\";\n    } else if (state & STATE_CHANGED) {\n      return \"move\";\n    } else if (state & STATE_BEGAN) {\n      return \"start\";\n    }\n    return \"\";\n  }\n\n  /**\n   * direction cons to string\n   * @param {Const} direction\n   * @returns {String}\n   */\n  function directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n      return \"down\";\n    } else if (direction == DIRECTION_UP) {\n      return \"up\";\n    } else if (direction == DIRECTION_LEFT) {\n      return \"left\";\n    } else if (direction == DIRECTION_RIGHT) {\n      return \"right\";\n    }\n    return \"\";\n  }\n\n  /**\n   * get a recognizer by name if it is bound to a manager\n   * @param {Recognizer|String} otherRecognizer\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer}\n   */\n  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n      return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n  }\n\n  /**\n   * This recognizer is just used as a base for the simple attribute recognizers.\n   * @constructor\n   * @extends Recognizer\n   */\n  function AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n  }\n\n  inherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n      /**\n       * @type {Number}\n       * @default 1\n       */\n      pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function(input) {\n      var optionPointers = this.options.pointers;\n      return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function(input) {\n      var state = this.state;\n      var eventType = input.eventType;\n\n      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n      var isValid = this.attrTest(input);\n\n      // on cancel input and we've recognized before, return STATE_CANCELLED\n      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n        return state | STATE_CANCELLED;\n      } else if (isRecognized || isValid) {\n        if (eventType & INPUT_END) {\n          return state | STATE_ENDED;\n        } else if (!(state & STATE_BEGAN)) {\n          return STATE_BEGAN;\n        }\n        return state | STATE_CHANGED;\n      }\n      return STATE_FAILED;\n    }\n  });\n\n  /**\n   * Pan\n   * Recognized when the pointer is down and moved in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n\n    this.pX = null;\n    this.pY = null;\n  }\n\n  inherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n      event: \"pan\",\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    },\n\n    directionTest: function(input) {\n      var options = this.options;\n      var hasMoved = true;\n      var distance = input.distance;\n      var direction = input.direction;\n      var x = input.deltaX;\n      var y = input.deltaY;\n\n      // lock to axis?\n      if (!(direction & options.direction)) {\n        if (options.direction & DIRECTION_HORIZONTAL) {\n          direction =\n            x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n          hasMoved = x != this.pX;\n          distance = Math.abs(input.deltaX);\n        } else {\n          direction =\n            y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n          hasMoved = y != this.pY;\n          distance = Math.abs(input.deltaY);\n        }\n      }\n      input.direction = direction;\n      return (\n        hasMoved &&\n        distance > options.threshold &&\n        direction & options.direction\n      );\n    },\n\n    attrTest: function(input) {\n      return (\n        AttrRecognizer.prototype.attrTest.call(this, input) &&\n        (this.state & STATE_BEGAN ||\n          (!(this.state & STATE_BEGAN) && this.directionTest(input)))\n      );\n    },\n\n    emit: function(input) {\n      this.pX = input.deltaX;\n      this.pY = input.deltaY;\n      var direction = directionStr(input.direction);\n\n      if (direction) {\n        input.additionalEvent = this.options.event + direction;\n      }\n      this._super.emit.call(this, input);\n    }\n  });\n\n  /**\n   * Pinch\n   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n      event: \"pinch\",\n      threshold: 0,\n      pointers: 2\n    },\n\n    attrTest: function(input) {\n      return (\n        this._super.attrTest.call(this, input) &&\n        (Math.abs(input.scale - 1) > this.options.threshold ||\n          this.state & STATE_BEGAN)\n      );\n    },\n\n    emit: function(input) {\n      if (input.scale !== 1) {\n        var inOut = input.scale < 1 ? \"in\" : \"out\";\n        input.additionalEvent = this.options.event + inOut;\n      }\n      this._super.emit.call(this, input);\n    }\n  });\n\n  /**\n   * Press\n   * Recognized when the pointer is down for x ms without any movement.\n   * @constructor\n   * @extends Recognizer\n   */\n  function PressRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    this._timer = null;\n    this._input = null;\n  }\n\n  inherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n      event: \"press\",\n      pointers: 1,\n      time: 251, // minimal time of the pointer to be pressed\n      threshold: 9 // a minimal movement is ok, but keep it low\n    },\n\n    process: function(input) {\n      var options = this.options;\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTime = input.deltaTime > options.time;\n\n      this._input = input;\n\n      // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n      if (\n        !validMovement ||\n        !validPointers ||\n        (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)\n      ) {\n        this.reset();\n      } else if (input.eventType & INPUT_START) {\n        this.reset();\n        this._timer = setTimeoutContext(\n          function() {\n            this.state = STATE_RECOGNIZED;\n            this.tryEmit();\n          },\n          options.time,\n          this\n        );\n      } else if (input.eventType & INPUT_END) {\n        return STATE_RECOGNIZED;\n      }\n      return STATE_FAILED;\n    },\n\n    reset: function() {\n      clearTimeout(this._timer);\n    },\n\n    emit: function(input) {\n      if (this.state !== STATE_RECOGNIZED) {\n        return;\n      }\n\n      if (input && input.eventType & INPUT_END) {\n        this.manager.emit(this.options.event + \"up\", input);\n      } else {\n        this._input.timeStamp = now();\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n\n  /**\n   * Rotate\n   * Recognized when two or more pointer are moving in a circular motion.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n      event: \"rotate\",\n      threshold: 0,\n      pointers: 2\n    },\n\n    attrTest: function(input) {\n      return (\n        this._super.attrTest.call(this, input) &&\n        (Math.abs(input.rotation) > this.options.threshold ||\n          this.state & STATE_BEGAN)\n      );\n    }\n  });\n\n  /**\n   * Swipe\n   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n      event: \"swipe\",\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    },\n\n    getTouchAction: function() {\n      return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n\n    attrTest: function(input) {\n      var direction = this.options.direction;\n      var velocity;\n\n      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n        velocity = input.overallVelocity;\n      } else if (direction & DIRECTION_HORIZONTAL) {\n        velocity = input.overallVelocityX;\n      } else if (direction & DIRECTION_VERTICAL) {\n        velocity = input.overallVelocityY;\n      }\n\n      return (\n        this._super.attrTest.call(this, input) &&\n        direction & input.offsetDirection &&\n        input.distance > this.options.threshold &&\n        input.maxPointers == this.options.pointers &&\n        abs(velocity) > this.options.velocity &&\n        input.eventType & INPUT_END\n      );\n    },\n\n    emit: function(input) {\n      var direction = directionStr(input.offsetDirection);\n      if (direction) {\n        this.manager.emit(this.options.event + direction, input);\n      }\n\n      this.manager.emit(this.options.event, input);\n    }\n  });\n\n  /**\n   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n   * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n   * a single tap.\n   *\n   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n   * multi-taps being recognized.\n   * @constructor\n   * @extends Recognizer\n   */\n  function TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n  }\n\n  inherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n      event: \"tap\",\n      pointers: 1,\n      taps: 1,\n      interval: 300, // max time between the multi-tap taps\n      time: 250, // max time of the pointer to be down (like finger on the screen)\n      threshold: 9, // a minimal movement is ok, but keep it low\n      posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    process: function(input) {\n      var options = this.options;\n\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTouchTime = input.deltaTime < options.time;\n\n      this.reset();\n\n      if (input.eventType & INPUT_START && this.count === 0) {\n        return this.failTimeout();\n      }\n\n      // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n      if (validMovement && validTouchTime && validPointers) {\n        if (input.eventType != INPUT_END) {\n          return this.failTimeout();\n        }\n\n        var validInterval = this.pTime\n          ? input.timeStamp - this.pTime < options.interval\n          : true;\n        var validMultiTap =\n          !this.pCenter ||\n          getDistance(this.pCenter, input.center) < options.posThreshold;\n\n        this.pTime = input.timeStamp;\n        this.pCenter = input.center;\n\n        if (!validMultiTap || !validInterval) {\n          this.count = 1;\n        } else {\n          this.count += 1;\n        }\n\n        this._input = input;\n\n        // if tap count matches we have recognized it,\n        // else it has began recognizing...\n        var tapCount = this.count % options.taps;\n        if (tapCount === 0) {\n          // no failing requirements, immediately trigger the tap event\n          // or wait as long as the multitap interval to trigger\n          if (!this.hasRequireFailures()) {\n            return STATE_RECOGNIZED;\n          } else {\n            this._timer = setTimeoutContext(\n              function() {\n                this.state = STATE_RECOGNIZED;\n                this.tryEmit();\n              },\n              options.interval,\n              this\n            );\n            return STATE_BEGAN;\n          }\n        }\n      }\n      return STATE_FAILED;\n    },\n\n    failTimeout: function() {\n      this._timer = setTimeoutContext(\n        function() {\n          this.state = STATE_FAILED;\n        },\n        this.options.interval,\n        this\n      );\n      return STATE_FAILED;\n    },\n\n    reset: function() {\n      clearTimeout(this._timer);\n    },\n\n    emit: function() {\n      if (this.state == STATE_RECOGNIZED) {\n        this._input.tapCount = this.count;\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n\n  /**\n   * Simple way to create a manager with a default set of recognizers.\n   * @param {cc.Node} element\n   * @param {Object} [options]\n   * @constructor\n   */\n  function Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(\n      options.recognizers,\n      Hammer.defaults.preset\n    );\n    return new Manager(element, options);\n  }\n\n  /**\n   * @const {string}\n   */\n  Hammer.VERSION = \"2.0.8\";\n\n  /**\n   * default settings\n   * @namespace\n   */\n  Hammer.defaults = {\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: TouchInput,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n      // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n      [RotateRecognizer, { enable: true }],\n      [PinchRecognizer, { enable: false }, [\"rotate\"]],\n      [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],\n      [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, [\"swipe\"]],\n      [TapRecognizer],\n      [TapRecognizer, { event: \"doubletap\", taps: 2 }, [\"tap\"]],\n      [PressRecognizer]\n    ]\n  };\n\n  var STOP = 1;\n  var FORCED_STOP = 2;\n\n  /**\n   * Manager\n   * @param {cc.Node} element\n   * @param {Object} [options]\n   * @constructor\n   */\n  function Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n\n    this.element = element;\n    this.elemenOriginPoint = element.getPosition();\n    this.input = createInputInstance(this);\n\n    each(\n      this.options.recognizers,\n      function(item) {\n        var recognizer = this.add(new item[0](item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n      },\n      this\n    );\n  }\n\n  Manager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function(options) {\n      assign(this.options, options);\n\n      if (options.inputTarget) {\n        // Clean up existing event listeners and reinitialize\n        this.input.destroy();\n        this.input.target = options.inputTarget;\n        this.input.init();\n      }\n      return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function(force) {\n      this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n      var session = this.session;\n      if (session.stopped) {\n        return;\n      }\n\n      var recognizer;\n      var recognizers = this.recognizers;\n\n      // this holds the recognizer that is being recognized.\n      // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n      // if no recognizer is detecting a thing, it is set to `null`\n      var curRecognizer = session.curRecognizer;\n\n      // reset when the last recognizer is recognized\n      // or when we're in a new session\n      if (\n        !curRecognizer ||\n        (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)\n      ) {\n        curRecognizer = session.curRecognizer = null;\n      }\n\n      var i = 0;\n      while (i < recognizers.length) {\n        recognizer = recognizers[i];\n\n        // find out if we are allowed try to recognize the input for this one.\n        // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n        //      that is being recognized.\n        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n        //      this can be setup with the `recognizeWith()` method on the recognizer.\n        if (\n          session.stopped !== FORCED_STOP && // 1\n          (!curRecognizer ||\n          recognizer == curRecognizer || // 2\n            recognizer.canRecognizeWith(curRecognizer))\n        ) {\n          // 3\n          recognizer.recognize(inputData);\n        } else {\n          recognizer.reset();\n        }\n\n        // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n        // current active recognizer. but only if we don't already have an active recognizer\n        if (\n          !curRecognizer &&\n          recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)\n        ) {\n          curRecognizer = session.curRecognizer = recognizer;\n        }\n        i++;\n      }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function(recognizer) {\n      if (recognizer instanceof Recognizer) {\n        return recognizer;\n      }\n\n      var recognizers = this.recognizers;\n      for (var i = 0; i < recognizers.length; i++) {\n        if (recognizers[i].options.event == recognizer) {\n          return recognizers[i];\n        }\n      }\n      return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function(recognizer) {\n      if (invokeArrayArg(recognizer, \"add\", this)) {\n        return this;\n      }\n\n      // remove existing\n      var existing = this.get(recognizer.options.event);\n      if (existing) {\n        this.remove(existing);\n      }\n\n      this.recognizers.push(recognizer);\n      recognizer.manager = this;\n\n      return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function(recognizer) {\n      if (invokeArrayArg(recognizer, \"remove\", this)) {\n        return this;\n      }\n\n      recognizer = this.get(recognizer);\n\n      // let's make sure this recognizer exists\n      if (recognizer) {\n        var recognizers = this.recognizers;\n        var index = inArray(recognizers, recognizer);\n\n        if (index !== -1) {\n          recognizers.splice(index, 1);\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @param {Object || Lexical Scope} context\n     * @returns {EventEmitter} this\n     */\n    on: function(events, handler, context, ...args) {\n      if (events === undefined) {\n        return;\n      }\n      if (handler === undefined) {\n        return;\n      }\n\n      var handlers = this.handlers;\n      var handlerBound = handler.bind(context, ...args);\n      each(splitStr(events), function(event) {\n        handlers[event] = handlers[event] || [];\n        handlers[event].push(handlerBound);\n      });\n      return handlerBound;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function(events, handlerBound) {\n      if (events === undefined) {\n        return;\n      }\n\n      var handlers = this.handlers;\n      each(splitStr(events), function(event) {\n        if (!handlerBound) {\n          delete handlers[event];\n        } else {\n          handlers[event] &&\n            handlers[event].splice(inArray(handlers[event], handlerBound), 1);\n        }\n      });\n      return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function(event, data) {\n      // no handlers, so skip it all\n      // console.log(\"eventType: \", event);\n      // console.log(\"handlers: \", this.handlers);\n      var handlers = this.handlers[event] && this.handlers[event].slice();\n      if (!handlers || !handlers.length) {\n        return;\n      }\n\n      data.type = event;\n\n      var i = 0;\n      while (i < handlers.length) {\n        handlers[i](data);\n        i++;\n      }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function() {\n      this.handlers = {};\n      this.session = {};\n      this.input.destroy();\n      this.element = null;\n    }\n  };\n\n  assign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n\n    Manager: Manager,\n    Input: Input,\n\n    TouchInput: TouchInput,\n\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn\n  });\n\n  // this prevents errors when Hammer is loaded in the presence of an AMD\n  //  style loader but by script tag, not by the loader.\n  var freeGlobal =\n    typeof window !== \"undefined\"\n      ? window\n      : typeof self !== \"undefined\"\n      ? self\n      : {}; // jshint ignore:line\n  freeGlobal.Hammer = Hammer;\n\n  if (typeof define === \"function\" && define.amd) {\n    define(function() {\n      return Hammer;\n    });\n  } else if (typeof module != \"undefined\" && module.exports) {\n    module.exports = Hammer;\n  } else {\n    window[exportName] = Hammer;\n  }\n})(\"Hammer\");\n"]}